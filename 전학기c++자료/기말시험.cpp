//-----------------------------------------------------------------------------
// 기말시험.cpp 
//-----------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "Shape.h"
#include "Triangle.h"
#include "Circle.h"

using namespace std;

extern default_random_engine dre;
uniform_int_distribution<> uid{ 0, 1 };					// 홀수와 짝수


//---------
int main( )
//---------
{
	//----------------------------------------
	// 이 소스파일은 문제없이 실행되어야 한다.
	//----------------------------------------
	Triangle aTriangle;
	Circle aCircle;	

	cout << '\n';
	cout << "시험시작 - 출력결과는 \"시험출력예시.txt\"를 참고하자" << '\n';
	cout << '\n';

	aTriangle.draw( );							
	aCircle.draw( );							



	//--------------------------------------------------------
	// 지금부터 순서대로 문제를 해결하고 답을 답안지에 적는다.
	//--------------------------------------------------------

	//-----------------------------------------------------------------------------------
	// [문제 1] Circle 객체 한 개의 크기가 몇 byte인지 화면에 출력하고 답지에도 적어라. 
	// 객체의 메모리를 그림으로 표현하라.							(20) 
	//-----------------------------------------------------------------------------------

	// 여기에 들어갈 코드와 출력된 결과(byte 수)를 답지에 적는다.	(코드, 출력 10)
	cout << "Circle 객체의 크기: " << sizeof(Circle) << " bytes" << endl;

	// 객체의 메모리 그림.											(그림 10)






	//--------------------------------------------
	// 다음은 도형을 관리하는데 필요한 변수들이다.
	// 모두 100개의 도형을 만들어 관리한다
	//--------------------------------------------

	int nShape = 100;					// 현재 관리하는 도형의 개수를 여기에 저장한다

	Shape** shapes;						// shapes는 Shape* 주소를 저장할 수 있다
	Shape* pShapes[100];				// pShapes는 Shape* 100개 배열이다

	shapes = pShapes;					// 이제 shapes는 Shape* 100개가 저장된 배열을 가리킨다	


	//----------------------------------------
	// 다형성이 구현됨을 확인해 보는 문제이다.
	//----------------------------------------

	//--------------------------------------------------------------------
	// [문제 2] 위에서 num 개의 도형을 관리할 수 있는 shapes를 생성하였다.
	// 관리하는 도형은 Circle과 Triangle 2가지 종류만 있다.
	// 
	// 랜덤엔진 dre와 랜덤분포 uid를 사용하여 값이 홀수이면 Triangle을, 
	// 짝수라면 Circle을 i번째 도형으로 생성하여
	// 100개의 도형을 shapes가 관리할 수 있도록 하라.				  (10)
	//
	// (주의) Circle과 Triangle을 default 생성하라.
	//-------------------------------------------------------------------- 	

	for (int i = 0; i < nShape; ++i) {
		int sel = uid( dre );

		// 랜덤 값 sel 에 따라 i번째 도형을 생성한다.

		// 여기에 들어갈 코드를 적으면 된다.						(코드 10)
		if (sel == 0) {
			shapes[i] = new Circle();  // Circle의 default 생성자 호출
		}
		else {
			shapes[i] = new Triangle();  // Triangle의 default 생성자 호출
		}

	}


	//--------------------------------------------------------------------------------------
	// [문제 3] 관리하는 모든 도형의 draw() 멤버를 호출하여 다형성이 구현됨을 보여라.	(10)
	//--------------------------------------------------------------------------------------

	cout << '\n';
	cout << "---------------------------------------------------" << '\n';
	cout << "[문제 3] 관리하는 100개 도형의 draw()를 호출한 결과" << '\n';
	cout << "---------------------------------------------------" << '\n';

	// 여기에 들어갈 코드를 답지에 적는다.							(코드 10)

	for (int i = 0; i < nShape; ++i) {
		shapes[i]->draw();
	}

	//------------------------------------------------------------------------------
	// [문제 4] 함수 findMaxRad()는 shapes와 nShape을 인자로 받아
	// shapes 중에서 가장 반지름 값이 큰 Circle을 찾은 후 그 Circle의 id를 리턴한다.
	// findMaxRad를 아래와 같이 호출하였다.
	// 함수 findMaxRad를 선언하고 정의하라. 					   (선언 5, 정의 15)
	//------------------------------------------------------------------------------

	cout << '\n';
	cout << "--------------------------------" << '\n';
	cout << "[문제 4] 반지름이 가장 큰 Circle" << '\n';
	cout << "--------------------------------" << '\n';


	// 아래의 주석을 풀고 실행되도록 하자
	int findmaxrad(shape * *shapes, int nshape) {
		int maxindex = -1;
		int maxradius = 0;
		for (int i = 0; i < nshape; ++i) {
			circle* circle = dynamic_cast<circle*>(shapes[i]);
			if (circle && circle->getrad() > maxradius) {
				maxradius = circle->getrad();
				maxindex = i;
			}
		}
		return maxindex;
	}

	int id = findmaxrad(shapes, nshape);
	if (id != -1) {
		cout << "반지름이 가장 큰 circle => ";
		shapes[id]->draw();
	}
	else {
		cout << "circle 객체가 없습니다." << endl;
	}



	//-----------------------------------------------------------------
	// [문제 5] 관리하는 도형을 qsort를 사용하여 정렬하라.
	// 정렬 기준은 도형의 타입이다.
	// Circle 타입이 앞에 오고 Triangle 타입은 Circle 타입 뒤에 나온다.
	// 출력 예시 화면을 참고하라.							      (20)
	//-----------------------------------------------------------------

	// 여기에 들어갈 코드를 답지에 적는다							(코드 20)

	cout << '\n';
	cout << "--------------------------------------------------------------------------------" << '\n';
	cout << "[문제 5] Circle과 Triangle 타입을 분리한 후 관리하는 도형의 draw()를 호출한 결과" << '\n';
	cout << "--------------------------------------------------------------------------------" << '\n';

	// draw를 호출한 코드는 3번 답에 해당하므로 감추었다.  






	//--------------------------------------
	// 문제 6을 위해 분리된 도형을 다시 섞음
	//--------------------------------------
	std::shuffle(&shapes[0], &shapes[100], dre);

	cout << '\n';
	cout << "-------------------------------------------------------" << '\n';
	cout << "[문제 5]의 결과를 무작위로 섞은 후 draw()를 호출한 결과" << '\n';
	cout << "-------------------------------------------------------" << '\n';

	// draw를 호출한 코드는 3번 답에 해당하므로 감추었다.  








	//--------------------------------------------------------------------------------- 
	// [문제 6 설명] 현재 shapes는 100개 도형의 주소를 저장하고 있는 메모리를 가리킨다.
	// 100개 도형 중에서 Circle만 골라 다른 메모리에 저장하려고 한다.
	// Circle만 따로 저장하게 될 메모리에는 Circle 객체를 직접 복사하지 않고 
	// Circle이 저장된 주소만 복사해도, 원하는 문제를 해결하기에 충분할 것이다.
	//--------------------------------------------------------------------------------- 

	//----------------------------------------------------------------------------------
	// [문제 6] 다음 순서에 따라 코딩하라.											(70)
	// 
	// (6-1) 100개 도형 중에서 Circle은 모두 몇 개인지 세어라. 
	//										-> Circle의 개수를 nCircle에 저장하라.	
	//										-> 출력된 개수를 답지에도 써라.         (10)
	//
	// (6-2) Circle* 형식의 자료 Circle개를 저장할 수 있는 메모리를 확보하라. 
	//										-> 이 메모리를 circles로 명명하라.		(10)
	//
	// (6-3) shapes 중에서 nCircle개의 Circle*를 circles에 복사하라.				(10)	
	//
	// (6-4) circles에 있는 모든 Circle의 반지름 값을 다음 수식을 사용하여 변경하라.
	//		 
	//		for (int i = 0; i < nCircle; ++i)
	//			*circles[i] = 2024 + *circles[i];	// 모든 Circle의 반지름을 2024 증가.
	//																				(20)				
	// 
	// (6-5) [문제 1]에서 [문제 6]까지 해결하면서 사용한 메모리를 모두 반환하라.	(20)
	// 
	// (주의) 답지에 (6-1)~(6-5)답을 구분해서 적을 것	
	// (주의) 문제와 관련하여 선언한 변수나 객체를 잊지말고 적을 것
	//----------------------------------------------------------------------------------


	cout << '\n';
	cout << "-----------------------------------------------------------------" << '\n';
	cout << "[문제 6] shapes중에서 nCircle개의 Circle 만 따로 관리하는 circles" << '\n';
	cout << "-----------------------------------------------------------------" << '\n';


	int nCircle{};

	// (6-1) 여기에 들어갈 코드를 적어라.							(코드 10)
	for (int i = 0; i < nShape; ++i) {
		if (dynamic_cast<Circle*>(shapes[i])) {
			++nCircle;
		}
	}

	cout << '\n';
	cout << "(6-1) nShape 중에서 Circle의 수 - " << nCircle << '\n';

	// (6-2) 여기에 들어갈 코드를 적어라.							(코드 10)

	Circle** circles = new Circle * [nCircle];

	// (6-3) 여기에 들어갈 코드를 적어라.							(코드 10)
	int index = 0;
	for (int i = 0; i < nShape; ++i) {
		if (Circle* circle = dynamic_cast<Circle*>(shapes[i])) {
			circles[index++] = circle;
		}
	}

	cout << '\n';
	cout << "(6-3) circles의 draw 호출" << '\n';

	// 여기에 있었던 draw() 호출은 감추었다.


	// (6-4) 다음 주석을 제거한 후 문장이 실행되도록 하라.							(코드 20)

	for (int i = 0; i < nCircle; ++i)
		circles[i]->setRad(2024 + circles[i]->getRad());



	cout << '\n';
	cout << "(6-4) 반지름을 2024 증가한 후 circles의 draw 호출" << '\n';

	// 여기에 있었던 draw() 호출은 감추었다.
	delete[] circles;
	for (int i = 0; i < nShape; ++i) {
		delete shapes[i];
	}


	cout << " - 메모리 해제 - " << endl;

}



