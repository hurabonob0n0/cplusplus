//-----------------------------------------------------------------//2024.2학기9.4수수78목78(1주1일)////한학기강의소개/교재////컴파일환경통일//1.Release모드/x64//2.언어-프로잭트설정-C++언어-미리보기최신C++//3.VS버전-17.11.2//-----------------------------------------------------------------//한학기강의를자동저장하는소스코드작성//~이내용은몰라도된다//-----------------------------------------------------------------#include<iostream>//#include<print>#include<string>#include<fstream>voidsave(conststd::string&);intmain(){std::cout<<"안녕?C++!"<<'\n';//std::println({:^50},"안녕?C++");//한학기강의를자동저장하는함수를만든다save(std::string{"메인.cpp"});}voidsave(conststd::string&inFileName){//전달된inFileName을읽기모드로연다std::ifstreamin{inFileName};//저장된파일을쓰기모드로연다std::ofstreamout{"20242C++수78목78.txt",std::ios::app};//읽을파일에서한글자를읽어쓸파일에쓴다charc;while(in>>c)out<<c;}//-----------------------------------------------------------------
//2024. 2학기 9.4 수         수78목78        (1주1일)
//
// 한학기 강의 소개 / 교재
// 
// 컴파일 환경 통일
// 1. Release 모드 / x64
// 2. 언어 - 프로잭트 설정 - C++언어 - 미리보기 최신 C++
// 3. VS 버전 - 17.11.2 
//-----------------------------------------------------------------
// 한학기 강의를 자동저장하는 소스코드 작성
// ~ 이 내용은 몰라도 된다
//-----------------------------------------------------------------

#include <iostream>
//#include <print>
#include <string>
#include <fstream>

void save(const std::string&);

int main()
{
	std::cout << "안녕? C++!" << '\n';
	//std::println({:^50}, "안녕? C++" );

	// 한학기 강의를 자동저장하는 함수를 만든다

	
	save(std::string{ "메인.cpp" });
}

void save(const std::string& inFileName)
{
	// 전달된 inFileName을 읽기 모드로 연다
	std::ifstream in{ inFileName };

	// 저장된 파일을 쓰기 모드로 연다
	std::ofstream out{ "2024 2 C++ 수78목78.txt",std::ios::app };

	// 읽을 파일에서 한 글자를 읽어 쓸 파일에 쓴다
	char c;
	in >> std::noskipws;
	while (in >> c)
		out << c;
}

======================================
저장시간:2024-09-05 06:51:08.0133683
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.4 수         수78목78        (1주2일)
//
// 참고 - C++ core guideline
// ----------------------------------------------------------------
// save 시간을 기록하고 파일을 분리한다.
// ----------------------------------------------------------------

#include <iostream>
//#include <print>
#include <string>
#include <fstream>
#include <chrono>

void save(const std::string&);

int main()
{
	std::cout << "안녕? C++!" << '\n';
	//std::println({:^50}, "안녕? C++" );

	// 한학기 강의를 자동저장하는 함수를 만든다

	
	save(std::string{ "메인.cpp" });
}

void save(const std::string& inFileName)
{
	// 전달된 inFileName을 읽기 모드로 연다
	std::ifstream in{ inFileName }; // {} - uniform initializer

	// 저장된 파일을 쓰기 모드로 연다
	std::ofstream out{ "2024 2 C++ 수78목78.txt",std::ios::app };

	// 저장한 시간을 기록한다
	auto now = std::chrono::system_clock::now();

	out << '\n' << '\n';
	out << "======================================" << '\n';
	out << "저장시간:" << now << '\n';
	out << "======================================" << '\n';
	out << '\n';

	// 읽을 파일에서 한 글자를 읽어 쓸 파일에 쓴다
	char c;
	in >> std::noskipws;
	while (in >> c)
		out << c;
}

======================================
저장시간:2024-09-05 15:54:38.7796849
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.4 수         수78목78        (1주2일)
//
// 참고 - C++ core guideline
// ----------------------------------------------------------------
// save 시간을 기록하고 파일을 분리한다.
// ----------------------------------------------------------------

#include <iostream>
//#include <print>
#include <string>
#include <fstream>
#include <chrono>

void save(const std::string&);

int main()
{
	std::cout << "안녕? C++!" << '\n';
	//std::println({:^50}, "안녕? C++" );

	// 한학기 강의를 자동저장하는 함수를 만든다

	
	save(std::string{ "메인.cpp" });
}

void save(const std::string& inFileName)
{
	// 전달된 inFileName을 읽기 모드로 연다
	std::ifstream in{ inFileName }; // {} - uniform initializer

	// 저장된 파일을 쓰기 모드로 연다
	std::ofstream out{ "2024 2 C++ 수78목78.txt",std::ios::app };

	// 저장한 시간을 기록한다
	auto now = std::chrono::system_clock::now();
	using namespace std::literals;
	now += 9h;

	out << '\n' << '\n';
	out << "======================================" << '\n';
	out << "저장시간:" << now << '\n';
	out << "======================================" << '\n';
	out << '\n';

	// 읽을 파일에서 한 글자를 읽어 쓸 파일에 쓴다
	char c;
	in >> std::noskipws;
	while (in >> c)
		out << c;
}

======================================
저장시간:2024-09-05 16:20:12.1049840
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.4 수         수78목78        (1주2일)
//
// 참고 - C++ core guideline
// ----------------------------------------------------------------
// save 시간을 기록하고 파일을 분리한다.
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	save( "메인.cpp" );
	save("save.h");
	save("save.cpp");
}



======================================
저장시간:2024-09-05 16:20:12.1105572
======================================

//-------------------------------------------------------
// save.h	한 학기 강의를 저장하기 위한 함수
//											2024.09.05
//-------------------------------------------------------
#pragma once

#include <string>

void save(const std::string&);



======================================
저장시간:2024-09-05 16:20:12.1166674
======================================

//-------------------------------------------------------
// save.cpp
//											2024.09.05
//-------------------------------------------------------

#include <string>
#include <fstream>
#include <chrono>

void save(const std::string& inFileName)
{
	// 전달된 inFileName을 읽기 모드로 연다
	std::ifstream in{ inFileName }; // {} - uniform initializer

	// 저장된 파일을 쓰기 모드로 연다
	std::ofstream out{ "2024 2 C++ 수78목78.txt",std::ios::app };

	// 저장한 시간을 기록한다
	auto now = std::chrono::system_clock::now();
	using namespace std::literals;
	now += 9h;

	out << '\n' << '\n';
	out << "======================================" << '\n';
	out << "저장시간:" << now << '\n';
	out << "======================================" << '\n';
	out << '\n';

	// 읽을 파일에서 한 글자를 읽어 쓸 파일에 쓴다
	char c;
	in >> std::noskipws;
	while (in >> c)
		out << c;
}

======================================
저장시간:2024-09-05 16:34:40.7020603
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.4 수         수78목78        (1주2일)
//
// ----------------------------------------------------------------
// C++ I/O 연습
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"
//using namespace 

//--------
int main()
//--------
{
	std::cout << "안녕? C++!" << std::endl;
	save( "메인.cpp" );
}



======================================
저장시간:2024-09-05 16:48:43.3713592
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.4 수         수78목78        (1주2일)
//
// ----------------------------------------------------------------
// C++ I/O 연습
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
//using namespace std;		//따라하지 말 것

// C++ 실행파일에는 프로그래머의 의도와 상관없이 항상 cout,cin,cerr,clog 객체가 default 생성
// cin은 키보드, 나머지 3개는 화면에 연결되어 있다.

//--------
int main()
//--------
{
	// [실습] 이름을 입력받아 환영인사를 출력하라.
	// 예) xx -> xx님, 반갑습니다.
	std::string name;

	std::cin >> name;
	std::cout << name << "님, 반갑습니다.";

	save( "메인.cpp" );
}



======================================
저장시간:2024-09-05 16:49:59.7084239
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.4 수         수78목78        (1주2일)
//
// ----------------------------------------------------------------
// C++ I/O 연습
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
//using namespace std;		//따라하지 말 것

// C++ 실행파일에는 프로그래머의 의도와 상관없이 항상 cout,cin,cerr,clog 객체가 default 생성
// cin은 키보드, 나머지 3개는 화면에 연결되어 있다.

//--------
int main()
//--------
{
	// [실습] 이름을 입력받아 환영인사를 출력하라.
	// 예) xx -> xx님, 반갑습니다.
	char name;

	std::cin >> name;
	std::cout << name << "님, 반갑습니다.";

	save( "메인.cpp" );
}



======================================
저장시간:2024-09-05 17:00:34.9871438
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.4 수         수78목78        (1주2일)
//
// ----------------------------------------------------------------
// C++ I/O 연습
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
//using namespace std;		//따라하지 말 것

// C++ 실행파일에는 프로그래머의 의도와 상관없이 항상 cout,cin,cerr,clog 객체가 default 생성
// cin은 키보드, 나머지 3개는 화면에 연결되어 있다.

//--------
int main()
//--------
{
	// [실습] 이름을 입력받아 환영인사를 출력하라.
	// 예) xx -> xx님, 반갑습니다.
	std::cout << "What's your name?";
	std::string name;		// string - dynamic data structure - 동적 자료구조

	std::cin >> name;
	std::cout << "입력하신 글자는 - " << name.length() << '\n';
	std::cout << name << "님, 반갑습니다.";

	save( "메인.cpp" );
}



======================================
저장시간:2024-09-05 17:06:23.0818362
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.4 수         수78목78        (1주2일)
//
// ----------------------------------------------------------------
// C++ I/O 연습
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
//using namespace std;		//따라하지 말 것

// C++ 실행파일에는 프로그래머의 의도와 상관없이 항상 cout,cin,cerr,clog 객체가 default 생성
// cin은 키보드, 나머지 3개는 화면에 연결되어 있다.

//--------
int main()
//--------
{
	// [실습] 몇단을 출력할지 물어보고 그 단에 해당하는 구구단 출력
	// 입력 3
	// 3 x 1 = 3
	// 3 x 2 = 6
	//
	// 3 x 9 = 27
	int abc;
	std::cout << "몇단을 출력하시겠습니까?";
	std::cin >> abc;
	std::cout << abc << " x 1 = " << abc * 1 << '\n';
	std::cout << abc << " x 2 = " << abc * 2 << '\n';
	std::cout << abc << " x 3 = " << abc * 3 << '\n';
	std::cout << abc << " x 4 = " << abc * 4 << '\n';
	std::cout << abc << " x 5 = " << abc * 5 << '\n';
	std::cout << abc << " x 6 = " << abc * 6 << '\n';
	std::cout << abc << " x 7 = " << abc * 7 << '\n';
	std::cout << abc << " x 8 = " << abc * 8 << '\n';
	std::cout << abc << " x 9 = " << abc * 9 << '\n';
	save( "메인.cpp" );
}



======================================
저장시간:2024-09-05 17:14:19.4820563
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.4 수         수78목78        (1주2일)
//
// ----------------------------------------------------------------
// C++ I/O 연습
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
//using namespace std;		//따라하지 말 것

// C++ 실행파일에는 프로그래머의 의도와 상관없이 항상 cout,cin,cerr,clog 객체가 default 생성
// cin은 키보드, 나머지 3개는 화면에 연결되어 있다.

//--------
int main()
//--------
{
	// [실습] 몇단을 출력할지 물어보고 그 단에 해당하는 구구단 출력
	// 입력 3
	// 3 x 1 = 3
	// 3 x 2 = 6
	//
	// 3 x 9 = 27
	int abc;
	std::cout << "몇단을 출력하시겠습니까?" << '\n';
	std::cin >> abc;
	for (int i = 1; i <= 9; ++i) {
		std::cout << abc << " x " << i << " = " << abc * i << '\n';
	}
	save( "메인.cpp" );
}



======================================
저장시간:2024-09-05 17:14:26.3820206
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.4 수         수78목78        (1주2일)
//
// ----------------------------------------------------------------
// C++ I/O 연습
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
//using namespace std;		//따라하지 말 것

// C++ 실행파일에는 프로그래머의 의도와 상관없이 항상 cout,cin,cerr,clog 객체가 default 생성
// cin은 키보드, 나머지 3개는 화면에 연결되어 있다.

//--------
int main()
//--------
{
	// [실습] 몇단을 출력할지 물어보고 그 단에 해당하는 구구단 출력
	// 입력 3
	// 3 x 1 = 3
	// 3 x 2 = 6
	//
	// 3 x 9 = 27
	int abc;
	std::cout << "몇단을 출력하시겠습니까?" << '\n';
	std::cin >> abc;
	for (int i = 1; i <= 9; ++i) {
		std::cout << abc << " x " << i << " = " << abc * i << '\n';
	}
	save( "메인.cpp" );
}


======================================
저장시간:2024-09-19 00:01:08.0559486
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.4 수         수78목78        (1주2일)
//
// ----------------------------------------------------------------
// C++ I/O 연습
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"
//using namespace std;		//따라하지 말 것

// C++ 실행파일에는 프로그래머의 의도와 상관없이 항상 cout,cin,cerr,clog 객체가 default 생성
// cin은 키보드, 나머지 3개는 화면에 연결되어 있다.

//--------
int main()
//--------
{
	// [실습] 몇단을 출력할지 물어보고 그 단에 해당하는 구구단 출력
	// 입력 3
	// 3 x 1 = 3
	// 3 x 2 = 6
	//
	// 3 x 9 = 27
	int abc;
	std::cout << "몇단을 출력하시겠습니까?" << '\n';
	std::cin >> abc;
	for (int i = 1; i <= 9; ++i) {
		std::cout << abc << " x " << i << " = " << abc * i << '\n';
	}
	save("메인.cpp");
}


======================================
저장시간:2024-09-19 09:03:18.1605841
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.4 수         수78목78        (2주1일)
// 내일 과제 설명 9.12.목요일	
// ----------------------------------------------------------------
// C++ I/O 연습
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include <print>
#include "save.h"
//using namespace std;		//따라하지 말 것

// C++ 실행파일에는 프로그래머의 의도와 상관없이 항상 cout,cin,cerr,clog 객체가 default 생성
// cin은 키보드, 나머지 3개는 화면에 연결되어 있다.

//--------
int main()
//--------
{
	// [실습] 구구단 전체를 예쁘게 출력하라

	for (int i = 2; i <= 9; ++i) {
		for (int j = 1; j <= 9; ++j) {
			std::println("{} * {} = {:2}", i, j, i*j);
		}
	}
	save("메인.cpp");
}


======================================
저장시간:2024-09-19 09:05:01.6378151
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.4 수         수78목78        (2주1일)
// 내일 과제 설명 9.12.목요일	
// ----------------------------------------------------------------
// C++ I/O 연습
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include <print>
#include "save.h"
//using namespace std;		//따라하지 말 것

// C++ 실행파일에는 프로그래머의 의도와 상관없이 항상 cout,cin,cerr,clog 객체가 default 생성
// cin은 키보드, 나머지 3개는 화면에 연결되어 있다.

//--------
int main()
//--------
{
	// [실습] 구구단 전체를 예쁘게 출력하라

	for (int i = 2; i <= 9; ++i) {
		for (int j = 1; j <= 9; ++j) {
			std::println("{} * {} = {:2}", i, j, i*j);
		}
		std::cout << "\n";
	}
	save("메인.cpp");
}



======================================
저장시간:2024-09-19 09:15:51.5799010
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.4 수         수78목78        (2주1일)
// 내일 과제 설명 9.12.목요일	
// ----------------------------------------------------------------
// C++ I/O 연습
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include <print>
#include "save.h"
//using namespace std;		//따라하지 말 것

// C++ 실행파일에는 프로그래머의 의도와 상관없이 항상 cout,cin,cerr,clog 객체가 default 생성
// cin은 키보드, 나머지 3개는 화면에 연결되어 있다.

//--------
int main()
//--------
{
	// [문제] int값 두개를 입력받아 합계를 계산하여 출력하라. 
	std::cout << "int의 합계를 알려주마" << std::endl;
	std::cout << "int값 2개를 입력하라 ";
	int n1, n2;
	
	std::cin >> n1 >> n2;
	std::cout << n1 << "+" << n2 << "=" << n1 + n2 << "\n";
	
	save("메인.cpp");
}


======================================
저장시간:2024-09-19 09:24:43.0572409
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.4 수         수78목78        (2주1일)
// 내일 과제 설명 9.12.목요일	
// ----------------------------------------------------------------
// C++ I/O 연습
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include <print>
#include "save.h"
//using namespace std;		//따라하지 말 것

// C++ 실행파일에는 프로그래머의 의도와 상관없이 항상 cout,cin,cerr,clog 객체가 default 생성
// cin은 키보드, 나머지 3개는 화면에 연결되어 있다.

//--------
int main()
//--------
{
	save("메인.cpp");
	// [문제] int값 두개를 입력받아 합계를 계산하여 출력하라. 
	// 이 과정을 영원히 반복하라.
	std::cout << "int의 합계를 알려주마" << std::endl;

	while(true){
		std::cout << "int값 2개를 입력하라 ";
		int n1, n2;
		std::cin >> n1 >> n2;
		std::cout << n1 << "+" << n2 << "=" << n1 + n2 << "\n";
	}
	
}


======================================
저장시간:2024-09-19 10:30:02.7908530
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.4 수         수78목78        (2주1일)
// 내일 과제 설명 9.12.목요일	
// ----------------------------------------------------------------
// 자료형과 변수
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	int num = 0b01111111'11111111'11111111'11111111;

	//int의 최댓값을 출력하라.
	std::cout << num << std::endl;
	save("메인.cpp");
}


======================================
저장시간:2024-09-19 10:31:08.8266557
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.4 수         수78목78        (2주1일)
// 내일 과제 설명 9.12.목요일	
// ----------------------------------------------------------------
// 자료형과 변수
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	int num = 0x7F'FF'FF'FF;

	//int의 최댓값을 출력하라.
	std::cout << num << std::endl;
	save("메인.cpp");
}


======================================
저장시간:2024-09-19 10:33:40.4649270
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.4 수         수78목78        (2주1일)
// 내일 과제 설명 9.12.목요일	
// ----------------------------------------------------------------
// 자료형과 변수
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	//int의 최댓값을 출력하라.
	std::cout << std::numeric_limits<int>::max() << std::endl;
	save("메인.cpp");
}


======================================
저장시간:2024-09-19 10:33:57.6117907
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.4 수         수78목78        (2주1일)
// 내일 과제 설명 9.12.목요일	
// ----------------------------------------------------------------
// 자료형과 변수
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	//int의 최솟값을 출력하라.
	std::cout << std::numeric_limits<int>::min() << std::endl;
	save("메인.cpp");
}


======================================
저장시간:2024-09-19 10:45:02.6233012
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.4 수         수78목78        (2주1일)
// 내일 과제 설명 9.12.목요일	
// ----------------------------------------------------------------
// 자료형과 변수
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	int num;

	// 메모리가 있을 때 언제나 다음 질문으로 정치를 알 수 있다.
	std::cout << "num의 크기 - " << sizeof num << std::endl;
	std::cout << "num의 주소 - " << std::addressof(num) << std::endl;
	std::cout << "num의 타입 - " << typeid(num).name() << std::endl;

	save("메인.cpp");
}


======================================
저장시간:2024-09-19 11:09:07.5561830
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.12 목         수78목78        (2주 2일)
// ----------------------------------------------------------------
// 과제 설명 - 9.12.목요일	
// ----------------------------------------------------------------
// 자료형과 변수
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	int n[]{ 1,2,3,4,5,6,7,8,9,10 };

	// [실습] n의 모든 원소(element)의 값을 화면 출력하라.
	for (int i = 0; i < 10; ++i)
		std::cout << n[i] << " ";
	std::cout << std::endl;
	save("메인.cpp");
}


======================================
저장시간:2024-09-19 11:13:29.9824556
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.12 목         수78목78        (2주 2일)
// ----------------------------------------------------------------
// 과제 설명 - 9.12.목요일	
// ----------------------------------------------------------------
// 자료형과 변수
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	int n[10];

	// [실습] n의 모든 원소(element)의 값을 화면 출력하라.
	for (int i = 0; i < sizeof n / sizeof(int); ++i)
		std::cout << n[i] << " ";
	std::cout << std::endl;
	save("메인.cpp");
}


======================================
저장시간:2024-09-19 11:13:36.8848633
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.12 목         수78목78        (2주 2일)
// ----------------------------------------------------------------
// 과제 설명 - 9.12.목요일	
// ----------------------------------------------------------------
// 자료형과 변수
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	int n[10]{};

	// [실습] n의 모든 원소(element)의 값을 화면 출력하라.
	for (int i = 0; i < sizeof n / sizeof(int); ++i)
		std::cout << n[i] << " ";
	std::cout << std::endl;
	save("메인.cpp");
}


======================================
저장시간:2024-09-19 11:16:52.7962519
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.12 목         수78목78        (2주 2일)
// ----------------------------------------------------------------
// 과제 설명 - 9.12.목요일	
// ----------------------------------------------------------------
// 자료형과 변수
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	int n[30]{ 1,3,5,7,9,2,4,6,8,10 };

	// [실습] n의 모든 원소(element)의 값을 화면 출력하라.
	for (int num : n)
		std::cout << num << " ";
	std::cout << std::endl;
	save("메인.cpp");
}


======================================
저장시간:2024-09-19 11:18:23.9889820
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.12 목         수78목78        (2주 2일)
// ----------------------------------------------------------------
// 과제 설명 - 9.12.목요일	
// ----------------------------------------------------------------
// 자료형과 변수
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	int n[30]{ 1,3,5,7,9,2,4,6,8,10 };

	// [실습] n의 모든 원소(element)의 값을 화면 출력하라.
	// range-based for >> range for
	for (int num : n)
		std::cout << num << " ";
	std::cout << std::endl;


	save("메인.cpp");
}


======================================
저장시간:2024-09-19 11:25:53.3274202
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.12 목         수78목78        (2주 2일)
// ----------------------------------------------------------------
// 과제 설명 - 9.12.목요일	
// ----------------------------------------------------------------
// 자료형과 변수
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	int n[30]{ 1,3,5,7,9,2,4,6,8,10 };
 
	for (int num : n)
		std::cout << num << " ";
	std::cout << std::endl;

	// [실습] n의 값중에서 가장 큰 값을 찾아 화면에 출력하라.
	int maxValue{ std::numeric_limits<int>::min()};
	for (int n : n) {
		if (maxValue < n) {
			maxValue = n;
		}
	}

	std::cout << "최댓값" << maxValue << std::endl;

	save("메인.cpp");
}


======================================
저장시간:2024-09-19 11:56:17.1428637
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.12 목         수78목78        (2주 2일)
// ----------------------------------------------------------------
// 9.18 추석 휴무 - 보강은 16주차 10.3(목) - 강의실 수업
// ----------------------------------------------------------------
// 랜덤엔진과 분포
// ----------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"

std::default_random_engine dre;	



//--------
int main()
//--------
{
	std::cout << "엔진크기    " << sizeof dre;

	save("메인.cpp");
}


======================================
저장시간:2024-09-19 11:57:57.2392950
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.12 목         수78목78        (2주 2일)
// ----------------------------------------------------------------
// 9.18 추석 휴무 - 보강은 16주차 10.3(목) - 강의실 수업
// ----------------------------------------------------------------
// 랜덤엔진과 분포
// ----------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"

std::default_random_engine dre;	
std::uniform_int_distribution uid;


//--------
int main()
//--------
{
	for (int i = 0; i < 10; ++i)
		std::cout << uid(dre) << std::endl;

	save("메인.cpp");
}


======================================
저장시간:2024-09-19 12:03:18.8349621
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.12 목         수78목78        (2주 2일)
// ----------------------------------------------------------------
// 9.18 추석 휴무 - 보강은 16주차 10.3(목) - 강의실 수업
// ----------------------------------------------------------------
// 랜덤엔진과 분포
// ----------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"

std::random_device rd;
std::default_random_engine dre{ rd( )};
std::uniform_int_distribution uid;


//--------
int main()
//--------
{
	for (int i = 0; i < 10; ++i)
		std::cout << uid(dre) << std::endl;

	save("메인.cpp");
}


======================================
저장시간:2024-09-19 12:17:30.5875171
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.12 목         수78목78        (2주 2일)
// ----------------------------------------------------------------
// 9.18 추석 휴무 - 보강은 16주차 10.3(목) - 강의실 수업
// ----------------------------------------------------------------
// 랜덤엔진과 분포
// ----------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"

std::random_device rd;
std::default_random_engine dre{ rd( )};
std::uniform_int_distribution uid{ 1, 9999 };


//--------
int main()
//--------
{
	for (int i = 0; i < 10; ++i)
		std::cout << uid(dre) << std::endl;

	save("메인.cpp");
}


======================================
저장시간:2024-09-19 12:29:02.3247176
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.12 목         수78목78        (2주 2일)
// ----------------------------------------------------------------
// 9.18 추석 휴무 - 보강은 16주차 10.3(목) - 강의실 수업
// ----------------------------------------------------------------
// 랜덤엔진과 분포
// ----------------------------------------------------------------

#include <iostream>
#include <random>
#include <print>
#include "save.h"

std::default_random_engine dre;
std::uniform_int_distribution uid{ 1, 9999 };


//--------
int main()
//--------
{
	int n[1000];

	// 랜덤값으로 n을 채운다.
	for (int& num : n)
		num = uid(dre);

	//n의 모든값을 화면 출력한다.
	for (int num : n) {
		std::print("{:8}", num);
	}
	std::cout << std::endl;

	save("메인.cpp");
}




======================================
저장시간:2024-09-19 12:40:09.4288749
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.12 목         수78목78        (2주 2일)
// ----------------------------------------------------------------
// 9.18 추석 휴무 - 보강은 16주차 10.3(목) - 강의실 수업
// ----------------------------------------------------------------
// 랜덤엔진과 분포
// ----------------------------------------------------------------

#include <iostream>
#include <random>
#include <print>
#include "save.h"

std::default_random_engine dre;
std::uniform_int_distribution uid{ 1, 9999 };


//--------
int main()
//--------
{
	int n[1000];

	// 랜덤값으로 n을 채운다.
	for (int& num : n)
		num = uid(dre);

	//n의 모든값을 화면 출력한다.
	for (int num : n) {
		std::print("{:8}", num);
	}
	std::cout << std::endl;

	// [문제] 사용자가 찾는 값이 있으면 알려주자.
	// 있으면 '찾았다' 없으면 '못 찾았다'라고 출력하라.

	int num1 = 0;
	int num2 = 0;
	std::cout << "찾는 값을 입력하시오 : ";
	std::cin >> num1;
	for (int i = 0; i < 1000; ++i) {
		if (n[i] == num1){
			num2 += 1;
		}
	}
	if (num2 == 1)
		std::cout << "찾았다";
	else
		std::cout << "못 찾았다";
	

	save("메인.cpp");
}


======================================
저장시간:2024-09-19 12:50:01.7637778
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.12 목         수78목78        (2주 2일)
// ----------------------------------------------------------------
// 9.18 추석 휴무 - 보강은 16주차 10.3(목) - 강의실 수업
// ----------------------------------------------------------------
// 랜덤엔진과 분포
// ----------------------------------------------------------------

#include <iostream>
#include <random>
#include <print>
#include "save.h"

std::default_random_engine dre;
std::uniform_int_distribution uid{ 1, 9999 };


//--------
int main()
//--------
{
	save("메인.cpp");

	int n[1000];

	// 랜덤값으로 n을 채운다.
	for (int& num : n)
		num = uid(dre);

	//n의 모든값을 화면 출력한다.
	for (int num : n) {
		std::print("{:8}", num);
	}
	std::cout << std::endl;

	// [문제] 사용자가 찾는 값이 있으면 알려주자.
	// 있으면 '찾았다' 없으면 '못 찾았다'라고 출력하라.

	while (true) {
		std::cout << "찾을 값은?";
		int num;
		std::cin >> num;

		bool flag{ false };
		for (int n : n) {
			if (num == n) {
				std::cout << num << "값을 찾았습니다." << std::endl;
				flag = true;
				break;
			}
		}
		if (not flag)
			std::cout << "못 찾았다" << std::endl;
	}
	
}



======================================
저장시간:2024-09-19 13:16:35.0431280
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.12 목         수78목78        (2주 2일)
// ----------------------------------------------------------------
// 9.18 추석 휴무 - 보강은 16주차 10.3(목) - 강의실 수업
// ----------------------------------------------------------------
// 랜덤엔진과 분포
// ----------------------------------------------------------------

#include <iostream>
#include <random>
#include <print>
#include "save.h"

std::default_random_engine dre;
std::uniform_int_distribution uid{ 1, 6 };


//--------
int main()
//--------
{
	// [문제] 다음과 같이 주사위를 100만번 던졌다. 
	// 각 숫자가 나올 확률을 화면출력하라.

	int n[1000000]{};
	double sum[6]{};

	for (int i = 0; i < 100'0000; ++i) {
		n[i] = uid(dre);
		for (int j = 0; j < 6; ++j) {
			if (n[i] == (j+1))
				sum[j] += 1;
		}
	}
	for (int k = 0; k < 6; ++k) {
		std::cout << k+1 << "이 나올 확률 : " << (sum[k]/100'0000) * 100 << "%" << std::endl;
	}

	save("메인.cpp");
	
}


======================================
저장시간:2024-09-19 15:43:53.7070013
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------
// 랜덤엔진과 분포
// ----------------------------------------------------------------

#include <iostream>
#include <random>
#include <print>
#include "save.h"

std::default_random_engine dre;
std::uniform_int_distribution uid{ 1, 6 };


//--------
int main()
//--------
{
	// [문제] 다음과 같이 주사위를 100만번 던졌다. 
	// 각 숫자가 나올 확률을 화면출력하라.

	int num[6]{};

	for (int i = 0; i < 100'0000; ++i) {
		num[uid(dre) - 1]++;
	}

	for(int i=0;i<6;++i){
		std::println("{}의 확률 - {:.2f}%", i, num[i] / 100'0000. * 100);
	}

	save("메인.cpp");
	
}



======================================
저장시간:2024-09-19 15:44:26.2802030
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------
// 랜덤엔진과 분포
// ----------------------------------------------------------------

#include <iostream>
#include <random>
#include <print>
#include "save.h"

std::default_random_engine dre;
std::uniform_int_distribution uid{ 1, 6 };


//--------
int main()
//--------
{
	// [문제] 다음과 같이 주사위를 100만번 던졌다. 
	// 각 숫자가 나올 확률을 화면출력하라.

	int num[6]{};

	for (int i = 0; i < 100'0000; ++i) {
		num[uid(dre) - 1]++;
	}

	for(int i=0;i<6;++i){
		std::println("{}의 확률 - {:.2f}%", i+1, num[i] / 100'0000. * 100);
	}

	save("메인.cpp");
	
}



======================================
저장시간:2024-09-19 15:49:13.8939684
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------
// 랜덤엔진과 분포
// ----------------------------------------------------------------
// 셤주사위
// ----------------------------------------------------------------

#include <iostream>
#include <random>
#include <print>
#include <array>
#include "save.h"

std::default_random_engine dre;
std::uniform_int_distribution uid{ 1, 6 };


//--------
int main()
//--------
{
	// [문제] 다음과 같이 주사위를 100만번 던졌다. 
	// 각 숫자가 나올 확률을 화면출력하라.

	//int num[6]{};	// 일반 배열은 앞으로 사용금지하자.
	std::array <int, 6> num{};	//완벽한 대체제

	for (int i = 0; i < 100'0000; ++i) {
		num[uid(dre) - 1]++;
	}

	for(int i=0;i<num.size();++i){
		std::println("{}의 확률 - {:.2f}%", i+1, num[i] / 100'0000. * 100);
	}

	save("메인.cpp");
	
}



======================================
저장시간:2024-09-19 16:00:57.1888477
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 10.3(목) - 강의실 수업
// ----------------------------------------------------------------
// 지역/전역/동적 메모리
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	int num = 1;	// initialization - 초기화
					// RAII(Resource Acquisition is Initialization)

	num = 123;		// assignment - 할당, 배정, 대입
	num = 234;	    
	
	save("메인.cpp");
	
}



======================================
저장시간:2024-09-19 16:37:14.6576859
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 10.3(목) - 강의실 수업
// ----------------------------------------------------------------
// 지역/전역/동적 메모리
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	// [문제] num은 몇 개의 int를 담을 수 있는가?
	// 당신의 결론은?
	
	{
		int num;
		std::cout << "num의 주소 - " << std::addressof(num) << std::endl;
	}

	{
		int num[10];
		for (int i = 0; i < 10; ++i)
			std::cout << "num[" << i << "]의 주소 - " << std::addressof(num[i]) << std::endl;
	}

	save("메인.cpp");
	
}



======================================
저장시간:2024-09-19 16:41:30.1826373
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 10.3(목) - 강의실 수업
// ----------------------------------------------------------------
// 지역/전역/동적 메모리
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

int g;

//--------
int main()
//--------
{
	// [문제] num은 몇 개의 int를 담을 수 있는가?
	// 당신의 결론은?
	
	{
		int num;
		std::cout << "num의 주소 - " << std::addressof(num) << std::endl;
	}

	{
		int num[10];
		for (int i = 0; i < 10; ++i)
			std::cout << "num[" << i << "]의 주소 - " << std::addressof(num[i]) << std::endl;
	}

	std::cout << std::endl;
	std::cout << "전역 g의 주소 - " << std::addressof(g) << std::endl;

	save("메인.cpp");
	
}



======================================
저장시간:2024-09-19 16:58:29.8967967
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 10.3(목) - 강의실 수업
// ----------------------------------------------------------------
// 지역/전역/동적 메모리
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	// [문제] num은 몇 개의 int를 담을 수 있는가?
	// 당신의 결론은?
	
	int num[100'000'000];

	num[99'999'999] = 12345;

	std::cout << num[99'999'999] << std::endl;
	

	save("메인.cpp");
	
}



======================================
저장시간:2024-09-19 17:02:10.5665771
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 10.3(목) - 강의실 수업
// ----------------------------------------------------------------
// 지역/전역/동적 메모리
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	// [문제] num은 몇 개의 int를 담을 수 있는가?
	// 당신의 결론은?
	
	int num[250'000];		//1Mb
	for (int i = 0; i < 250'000; ++i)
		num[i] = i;

	for (int i = 0; i < 100; ++i)
		std::cout << num[i] << " ";

	std::cout << std::endl;
	
	save("메인.cpp");
	
}



======================================
저장시간:2024-09-19 17:02:27.0606952
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 10.3(목) - 강의실 수업
// ----------------------------------------------------------------
// 지역/전역/동적 메모리
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	// [문제] num은 몇 개의 int를 담을 수 있는가?
	// 당신의 결론은?
	
	int num[251'000];		//1Mb
	for (int i = 0; i < 251'000; ++i)
		num[i] = i;

	for (int i = 0; i < 100; ++i)
		std::cout << num[i] << " ";

	std::cout << std::endl;
	
	save("메인.cpp");
	
}



======================================
저장시간:2024-09-19 17:06:32.3110232
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 10.3(목) - 강의실 수업
// ----------------------------------------------------------------
// 지역/전역/동적 메모리
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	// [문제] num은 몇 개의 int를 담을 수 있는가?
	// 당신의 결론은?

	// num은 지역변수인데 디폴트 크기는 1Mb다
	// 대략 25만개의 int를 담을 수 있다
	
	int num[251'000];		//1Mb
	for (int i = 0; i < 251'000; ++i)
		num[i] = i;

	for (int i = 0; i < 100; ++i)
		std::cout << num[i] << " ";

	std::cout << std::endl;
	
	save("메인.cpp");
	
}



======================================
저장시간:2024-09-19 17:16:41.4320392
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 10.3(목) - 강의실 수업
// ----------------------------------------------------------------
// 지역/전역/동적 메모리
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

int num[0x7f'ff'ff'ff / 4];
//--------
int main()
//--------
{
	// [문제] 당신은 전역변수를 최대 얼마까지 확보할 수 있나요?
	// 확보한 메모리의 크기를 화면에 출력해보세요.
	
	std::cout << "전역배열 num의 크기 - " << sizeof num << std::endl;

	save("메인.cpp");
	
}



======================================
저장시간:2024-09-26 15:43:50.0287334
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 10.3(목) - 강의실 수업
// ----------------------------------------------------------------
// 지역/전역/동적 메모리
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

char num[2'000'000'000];
//--------
int main()
//--------
{
	// [문제] 당신은 전역변수를 최대 얼마까지 확보할 수 있나요?
	// 확보한 메모리의 크기를 화면에 출력해보세요.
	
	std::cout << "전역배열 num의 크기 - " << sizeof num << std::endl;
	
	save("메인.cpp");
	
}



======================================
저장시간:2024-09-26 16:20:47.8798775
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 10.3(목) - 강의실 수업
// ----------------------------------------------------------------
// 지역/전역/동적 메모리
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

void f()
{
	std::cout << "누가 f를 호출하였다." << " ";
	char c[100'000];
	for (char c : c)
		c = 'A';

	f();

	std::cout << c[0] << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");
	// [문제] STACK을 프로그램이 실행되는 동안 넘치게 코딩해 보시오.

	f();

	
	
}



======================================
저장시간:2024-09-26 16:41:10.6882830
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 10.3(목) - 강의실 수업
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 포인터와 래퍼런스
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

void change(int *a, int *b)
{
	int c;
	c = *a;
	*a = *b;
	*b = c;
}

//--------
int main()
//--------
{
	int a{ 1 }, b{ 2 };

	// [문제] 여기에서 a와 b를 인자로 하여 change 함수를 호출하였다.
	// 아래의 출력 예시와 같이 출력되도록 
	// 함수 change를 선언하고 정의한 후 호출하라.

	change(&a, &b);

	std::cout << a << ", " << b << std::endl;	// [출력예시] 2, 1
	
	save("메인.cpp");
}



======================================
저장시간:2024-09-26 16:56:08.8369186
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 10.3(목) - 강의실 수업
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 포인터와 래퍼런스
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

void change(int*, int*);

//--------
int main()
//--------
{
	int a{ 1 }, b{ 2 };

	// [문제] 여기에서 a와 b를 인자로 하여 change 함수를 호출하였다.
	// 아래의 출력 예시와 같이 출력되도록 
	// 함수 change를 선언하고 정의한 후 호출하라.

	change(&a, &b);		//function call

	std::cout << a << ", " << b << std::endl;	// [출력예시] 2, 1
	
	save("메인.cpp");
}

void change(int* x, int* y)
{
	int temp{ *x };
	*x = *y;
	*y = temp;
}


======================================
저장시간:2024-09-26 17:18:06.0392932
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 10.3(목) - 강의실 수업
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 포인터와 래퍼런스
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

void change(int&, int&);		//function declaration

//--------
int main()
//--------
{
	// C++은 포인터를 대체하는 refernce를 제공한다

	int a{ 1 }, b{ 2 };

	change(a, b);		//call by reference

	std::cout << a << ", " << b << std::endl;
	
	save("메인.cpp");
}

void change(int& x, int& y)		//function definition
{
	int temp{ x };
	x = y;
	y = temp;
}


======================================
저장시간:2024-10-02 16:00:55.1591060
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 10.3(목) - 강의실 수업
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 포인터와 래퍼런스
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

void change(int&, int&);		//function declaration

void change(int& x, int& y)		//function definition
{
	int temp{ x };
	x = y;
	y = temp;
}

// [문제] 다음 코드는 실행되는 C++의 일부분이다.
// 화면에 출력되는 내용을 적어라.	정확히 알 수 없다
// 그렇게 생각한 이유는?	오버로딩이 가능하기 때문에 함수의 선언문을 보기 전까지는 알 수 없다

//--------
int main()
//--------
{
	


	int a{ 1 }, b{ 2 };

	change(a, b);		//call by reference

	std::cout << a << ", " << b << std::endl;
	
	save("메인.cpp");
}



======================================
저장시간:2024-10-02 16:06:59.9776871
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 10.3(목) - 강의실 수업
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 포인터와 래퍼런스
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

void change(int&, int&);		//function declaration

void change(int& x, int& y)		//function definition
{
	int temp{ x };
	x = y;
	y = temp;
}

// [문제] 다음 코드는 실행되는 C++의 일부분이다.
// 화면에 출력되는 내용을 적어라.	정확히 알 수 없다
// 그렇게 생각한 이유는?	오버로딩이 가능하기 때문에 함수의 선언문을 보기 전까지는 알 수 없다

//--------
int main()
//--------
{
	int a[]{ 3,9,1,5,7,8,2,6,4,0 };

	// [실습] a의 값 중에서 가장 큰 값인 9를 제일 오른쪽으로 이동시켜라.

	for (int i = 0; i < 9; ++i) {
		if (a[i] > a[i + 1])
			change(a[i], a[i + 1]);
	}

	for (int num : a)
		std::cout << num << ' ';
	std::cout << std::endl;
	
	save("메인.cpp");
}



======================================
저장시간:2024-10-02 16:10:43.9059631
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 10.3(목) - 강의실 수업
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 포인터와 래퍼런스
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

void change(int&, int&);		//function declaration

void change(int& x, int& y)		//function definition
{
	int temp{ x };
	x = y;
	y = temp;
}

// [문제] 다음 코드는 실행되는 C++의 일부분이다.
// 화면에 출력되는 내용을 적어라.	정확히 알 수 없다
// 그렇게 생각한 이유는?	오버로딩이 가능하기 때문에 함수의 선언문을 보기 전까지는 알 수 없다

//--------
int main()
//--------
{
	int a[]{ 3,9,1,5,7,8,2,6,4,0 };

	// [실습] a의 값 중에서 가장 큰 값인 9를 제일 오른쪽으로 이동시켜라.

	for (int i = 0; i < 9; ++i) {	//for (int i = 0; i < NUM - 1; ++i)
		if (a[i] > a[i + 1])
			change(a[i], a[i + 1]);
	}

	for (int num : a)
		std::cout << num << ' ';
	std::cout << std::endl;
	
	save("메인.cpp");
}



======================================
저장시간:2024-10-02 16:12:24.8990773
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 10.3(목) - 강의실 수업
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 포인터와 래퍼런스
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

void change(int&, int&);		//function declaration

void change(int& x, int& y)		//function definition
{
	int temp{ x };
	x = y;
	y = temp;
}

// [문제] 다음 코드는 실행되는 C++의 일부분이다.
// 화면에 출력되는 내용을 적어라.	정확히 알 수 없다
// 그렇게 생각한 이유는?	오버로딩이 가능하기 때문에 함수의 선언문을 보기 전까지는 알 수 없다

//--------
int main()
//--------
{
	int a[]{ 3,9,1,5,7,8,2,6,4,0 };

	// [실습] a의 값 중에서 가장 큰 값인 9를 제일 오른쪽으로 이동시켜라.

	for (int i = 0; i < 10-1; ++i) {	//for (int i = 0; i < NUM - 1; ++i)
		if (a[i] > a[i + 1])
			change(a[i], a[i + 1]);
	}

	for (int num : a)
		std::cout << num << ' ';
	std::cout << std::endl;
	
	save("메인.cpp");
}



======================================
저장시간:2024-10-02 16:17:12.9414995
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 10.3(목) - 강의실 수업
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 포인터와 래퍼런스
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

void change(int&, int&);		//function declaration

void change(int& x, int& y)		//function definition
{
	int temp{ x };
	x = y;
	y = temp;
}

// [문제] 다음 코드는 실행되는 C++의 일부분이다.
// 화면에 출력되는 내용을 적어라.	정확히 알 수 없다
// 그렇게 생각한 이유는?	오버로딩이 가능하기 때문에 함수의 선언문을 보기 전까지는 알 수 없다

//--------
int main()
//--------
{
	int a[]{ 3,9,1,5,7,8,2,6,4,0 };

	// [실습] a를 오름차순( ascending order )으로 정렬( sort )하시오.
	for(int j=0;j<11;++j)
	{
		for (int i = 0; i < 10 - 1; ++i) {
			if (a[i] > a[i + 1])
				change(a[i], a[i + 1]);
		}
	}

	for (int num : a)
		std::cout << num << ' ';
	std::cout << std::endl;
	
	save("메인.cpp");
}



======================================
저장시간:2024-10-02 16:20:19.2780117
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 10.3(목) - 강의실 수업
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 포인터와 래퍼런스
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

void change(int&, int&);		//function declaration

void change(int& x, int& y)		//function definition
{
	int temp{ x };
	x = y;
	y = temp;
}

// [문제] 다음 코드는 실행되는 C++의 일부분이다.
// 화면에 출력되는 내용을 적어라.	정확히 알 수 없다
// 그렇게 생각한 이유는?	오버로딩이 가능하기 때문에 함수의 선언문을 보기 전까지는 알 수 없다

//--------
int main()
//--------
{
	int a[]{ 3,9,1,5,7,8,2,6,4,0 };

	// [실습] a를 오름차순( ascending order )으로 정렬( sort )하시오.
	for(int j=1;j<=11;++j)
	{
		for (int i = 0; i < 10 - j; ++i) {
			if (a[i] > a[i + 1])
				change(a[i], a[i + 1]);
		}
	}

	for (int num : a)
		std::cout << num << ' ';
	std::cout << std::endl;
	
	save("메인.cpp");
}



======================================
저장시간:2024-10-02 16:20:56.7459022
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 10.3(목) - 강의실 수업
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 포인터와 래퍼런스
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

void change(int&, int&);		//function declaration

void change(int& x, int& y)		//function definition
{
	int temp{ x };
	x = y;
	y = temp;
}

// [문제] 다음 코드는 실행되는 C++의 일부분이다.
// 화면에 출력되는 내용을 적어라.	정확히 알 수 없다
// 그렇게 생각한 이유는?	오버로딩이 가능하기 때문에 함수의 선언문을 보기 전까지는 알 수 없다

//--------
int main()
//--------
{
	int a[]{ 3,9,1,5,7,8,2,6,4,0 };

	// [실습] a를 오름차순( ascending order )으로 정렬( sort )하시오.
	for(int j=1;j<11;++j)
	{
		for (int i = 0; i < 10 - j; ++i) {
			if (a[i] > a[i + 1])
				change(a[i], a[i + 1]);
		}
	}

	for (int num : a)
		std::cout << num << ' ';
	std::cout << std::endl;
	
	save("메인.cpp");
}



======================================
저장시간:2024-10-02 16:26:13.7743042
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 10.3(목) - 강의실 수업
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 포인터와 래퍼런스
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

void change(int&, int&);		//function declaration

void change(int& x, int& y)		//function definition
{
	int temp{ x };
	x = y;
	y = temp;
}

// [문제] 다음 코드는 실행되는 C++의 일부분이다.
// 화면에 출력되는 내용을 적어라.	정확히 알 수 없다
// 그렇게 생각한 이유는?	오버로딩이 가능하기 때문에 함수의 선언문을 보기 전까지는 알 수 없다

//--------
int main()
//--------
{
	int a[]{ 3,9,1,5,7,8,2,6,4,0 };

	// [실습] a를 오름차순( ascending order )으로 정렬( sort )하시오.
	for(int j=0;j<10-1;++j){
		for (int i = 0; i < 10 - 1 - j; ++i) {
			if (a[i] > a[i + 1])
				change(a[i], a[i + 1]);
		}
	}

	for (int num : a)
		std::cout << num << ' ';
	std::cout << std::endl;
	
	save("메인.cpp");
}



======================================
저장시간:2024-10-02 17:19:29.0894399
======================================

// ----------------------------------------------------------------
// 2024. 2학기 9.17 목         수78목78        (3주 1일)
// ----------------------------------------------------------------
// 10.3(목) - 강의실 수업
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 포인터와 래퍼런스
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

void change(int&, int&);		//function declaration

void change(int& x, int& y)		//function definition
{
	int temp{ x };
	x = y;
	y = temp;
}

// [문제] 다음 코드는 실행되는 C++의 일부분이다.
// 화면에 출력되는 내용을 적어라.	정확히 알 수 없다
// 그렇게 생각한 이유는?	오버로딩이 가능하기 때문에 함수의 선언문을 보기 전까지는 알 수 없다

//--------
int main()
//--------
{
	int a[]{ 3,9,1,5,7,8,2,6,4,0 };

	// [실습] a를 qsort를 사용하여 오름차순( ascending order )으로 정렬( sort )하시오.
	// qsort는 generic 함수이다.

	int 오름차순(const void*, const void*);
	qsort(a, sizeof(a) / sizeof(int), sizeof(int), 오름차순);		// qsort는 자료형과 무관하게 정렬가능하다.

	for (int num : a)
		std::cout << num << ' ';
	std::cout << std::endl;
	
	save("메인.cpp");
}

int 오름차순(const void* p, const void* q)
{
	// 의미는 다음시간
	int x = *(int*)p;
	int y = *(int*)q;

	if (x < y)
		return -1;
	else if (x > y)
		return 1;
	else
		return 0;
}

======================================
저장시간:2024-10-03 15:55:42.0018156
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.3 수         수78목78        (5주 1일)
// ----------------------------------------------------------------
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 정렬
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

void change(int&, int&);		//function declaration

void change(int& x, int& y)		//function definition
{
	int temp{ x };
	x = y;
	y = temp;
}

// [문제] 다음 코드는 실행되는 C++의 일부분이다.
// 화면에 출력되는 내용을 적어라.	정확히 알 수 없다
// 그렇게 생각한 이유는?	오버로딩이 가능하기 때문에 함수의 선언문을 보기 전까지는 알 수 없다

//--------
int main()
//--------
{
	int a[]{ 3,9,1,5,7,8,2,6,4,0 };

	// [실습] a를 qsort를 사용하여 오름차순( ascending order )으로 정렬( sort )하시오.
	// qsort는 generic 함수이다.

	int 오름차순(const void*, const void*);
	qsort(a, sizeof(a) / sizeof(int), sizeof(int), 오름차순);		//qsort(a,개수,바이트,함수포인터);
	// a가 오름차순으로 정렬되도록 "오름차순"을 선언하고 정리하라.



	for (int num : a)
		std::cout << num << ' ';
	std::cout << std::endl;
	
	save("메인.cpp");
}

int 오름차순(const void* p, const void* q)
{
	
	// void* - 인자로 전달할 때 어떤 형식인지 알 수 없다.
	// 인자를 받는 함수에서 원하는 형식으로 casting 하면 됨

	// const - 해당 메모리는 읽기만 할 수 있음을 의미함.	const : read only menory 

	int x = *(int*)p;
	int y = *(int*)q;

	if (x < y)
		return -1; 
	else if (x > y)
		return 1;
	else
		return 0;
}

//qsort(a,10,4,함수포인터);

======================================
저장시간:2024-10-03 15:56:56.6895480
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.3 수         수78목78        (5주 1일)
// ----------------------------------------------------------------
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 정렬
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

void change(int&, int&);		//function declaration

void change(int& x, int& y)		//function definition
{
	int temp{ x };
	x = y;
	y = temp;
}

// [문제] 다음 코드는 실행되는 C++의 일부분이다.
// 화면에 출력되는 내용을 적어라.	정확히 알 수 없다
// 그렇게 생각한 이유는?	오버로딩이 가능하기 때문에 함수의 선언문을 보기 전까지는 알 수 없다

//--------
int main()
//--------
{
	int a[]{ 3,9,1,5,7,8,2,6,4,0 };

	// [실습] a를 qsort를 사용하여 오름차순( ascending order )으로 정렬( sort )하시오.
	// qsort는 generic 함수이다.

	int 오름차순(const void*, const void*);
	qsort(a, sizeof(a) / sizeof(int), sizeof(int), 오름차순);		//qsort(a,개수,바이트,함수포인터);
	// a가 오름차순으로 정렬되도록 "오름차순"을 선언하고 정리하라.



	for (int num : a)
		std::cout << num << ' ';
	std::cout << std::endl;
	
	save("메인.cpp");
}

int 오름차순(const void* p, const void* q)
{
	
	return *(int*)q - *(int*)p;
}

======================================
저장시간:2024-10-03 15:57:34.6489421
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.3 수         수78목78        (5주 1일)
// ----------------------------------------------------------------
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 정렬
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

void change(int&, int&);		//function declaration

void change(int& x, int& y)		//function definition
{
	int temp{ x };
	x = y;
	y = temp;
}

// [문제] 다음 코드는 실행되는 C++의 일부분이다.
// 화면에 출력되는 내용을 적어라.	정확히 알 수 없다
// 그렇게 생각한 이유는?	오버로딩이 가능하기 때문에 함수의 선언문을 보기 전까지는 알 수 없다

//--------
int main()
//--------
{
	int a[]{ 3,9,1,5,7,8,2,6,4,0 };

	// [실습] a를 qsort를 사용하여 오름차순( ascending order )으로 정렬( sort )하시오.
	// qsort는 generic 함수이다.

	int 오름차순(const void*, const void*);
	qsort(a, sizeof(a) / sizeof(int), sizeof(int), 오름차순);		//qsort(a,개수,바이트,함수포인터);
	// a가 오름차순으로 정렬되도록 "오름차순"을 선언하고 정리하라.



	for (int num : a)
		std::cout << num << ' ';
	std::cout << std::endl;
	
	save("메인.cpp");
}

int 오름차순(const void* p, const void* q)
{
	
	return *(int*)q - *(int*)p;		//내림차순 
}

======================================
저장시간:2024-10-03 16:08:04.8240224
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.3 수         수78목78        (5주 1일)
// ----------------------------------------------------------------
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 정렬
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

void change(int&, int&);		//function declaration

void change(int& x, int& y)		//function definition
{
	int temp{ x };
	x = y;
	y = temp;
}

// [문제] 다음 코드는 실행되는 C++의 일부분이다.
// 화면에 출력되는 내용을 적어라.	정확히 알 수 없다
// 그렇게 생각한 이유는?	오버로딩이 가능하기 때문에 함수의 선언문을 보기 전까지는 알 수 없다

int 오름차순(const void*, const void*);

//--------
int main()
//--------
{
	char c[]{ "quick brown fox jumps over the lazy dog" };

	// [문제] c를 qsort를 사용하여 오름차순으로 정렬하라. 
	// 정렬된 c를 화면 출력하라.
	
	qsort(c, sizeof(c) / sizeof(char), sizeof(char), 오름차순);
	for (int i = 0; i < sizeof(c) / sizeof(char) - 1; ++i) {
		std::cout << c[i] << std::endl;
	}

	save("메인.cpp");
}

int 오름차순(const void* p, const void* q)
{
	char x = *(char*)p;
	char y = *(char*)q;

	if (x < y)
		return -1;
	else if (x > y)
		return 1;
	else
		return 0;
}

======================================
저장시간:2024-10-03 16:10:47.7422564
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.3 수         수78목78        (5주 1일)
// ----------------------------------------------------------------
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 정렬
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

void change(int&, int&);		//function declaration

void change(int& x, int& y)		//function definition
{
	int temp{ x };
	x = y;
	y = temp;
}

// [문제] 다음 코드는 실행되는 C++의 일부분이다.
// 화면에 출력되는 내용을 적어라.	정확히 알 수 없다
// 그렇게 생각한 이유는?	오버로딩이 가능하기 때문에 함수의 선언문을 보기 전까지는 알 수 없다

int 오름(const void*, const void*);

//--------
int main()
//--------
{
	char c[]{ "quick brown fox jumps over the lazy dog" };

	// [문제] c를 qsort를 사용하여 오름차순으로 정렬하라. 
	// 정렬된 c를 화면 출력하라.
	
	qsort(c, strlen(c), sizeof(char), 오름);
	for (char c : c)
		std::cout << c;
	std::cout << std::endl;
	save("메인.cpp");
}

int 오름(const void* a, const void* b)
{
	return *(char*)a - *(char*)b;
}

======================================
저장시간:2024-10-03 16:11:19.1696963
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.3 수         수78목78        (5주 1일)
// ----------------------------------------------------------------
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 정렬
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

void change(int&, int&);		//function declaration

void change(int& x, int& y)		//function definition
{
	int temp{ x };
	x = y;
	y = temp;
}

// [문제] 다음 코드는 실행되는 C++의 일부분이다.
// 화면에 출력되는 내용을 적어라.	정확히 알 수 없다
// 그렇게 생각한 이유는?	오버로딩이 가능하기 때문에 함수의 선언문을 보기 전까지는 알 수 없다

int 오름(const void*, const void*);

//--------
int main()
//--------
{
	char c[]{ "quick brown fox jumps over the lazy dog" };

	// [문제] c를 qsort를 사용하여 오름차순으로 정렬하라. 
	// 정렬된 c를 화면 출력하라.
	
	qsort(c, strlen(c), sizeof(char), 오름);
	std::cout << c << std::endl;
	save("메인.cpp");
}

int 오름(const void* a, const void* b)
{
	return *(char*)a - *(char*)b;
}

======================================
저장시간:2024-10-03 16:38:23.8964566
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.3 수         수78목78        (5주 1일)
// ----------------------------------------------------------------
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 정렬
// ----------------------------------------------------------------

#include <iostream>
#include <array>
#include <random>
#include <print>
#include "save.h"

std::default_random_engine dre;
std::uniform_int_distribution uid{ 1, 9999 };

int 오차(const void*, const void*);

//--------
int main()
//--------
{
	// [실습] int값 1'000개를 저장할 메모리를 만든다.
	// 각 int값을 [1, 9'999] 범위의 랜덤값으로 채우자.
	// 오름차순으로 정렬하라.
	// 각 int를 8칸에 맞추어 화면출력하자.

	std::array<int, 1'000> a;

	for (int& num : a)
		num = uid(dre);

	qsort(a.data(), a.size(), sizeof(int), 오차);
		 //= &a[0]

	for (int n : a)
		std::print("{:>8d}", n);
	std::cout << std::endl;

	save("메인.cpp");
}

int 오차(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}

======================================
저장시간:2024-10-03 17:03:59.4075494
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.3 수         수78목78        (5주 1일)
// ----------------------------------------------------------------
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 정렬
// ----------------------------------------------------------------
// 함수 overloading이 가능한 이유는 C++ compiler가 이름은 mangling 하기 때문
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

int 오차(const void*, const void*);

//--------
int main()
//--------
{
	
	int a[3]{ 3,1,2 };

	qsort(a, sizeof(a) / sizeof(int), sizeof(int), 오차);

	for (int n : a)
		std::cout << n << ' ';
	std::cout << std::endl;

	save("메인.cpp");
}

int 오차(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}

======================================
저장시간:2024-10-03 17:12:59.6669233
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.3 수         수78목78        (5주 1일)
// ----------------------------------------------------------------
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 정렬
// ----------------------------------------------------------------
// 함수 overloading이 가능한 이유는 C++ compiler가 이름은 mangling 하기 때문
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	
	int a[3]{ 3,1,2 };

	qsort(a, sizeof(a) / sizeof(int), sizeof(int), [](const void* a, const void* b){
		return *(int*)a - *(int*)b; 
		});

	for (int n : a)
		std::cout << n << ' ';
	std::cout << std::endl;

	save("메인.cpp");
}



======================================
저장시간:2024-10-03 17:13:09.6170060
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.3 수         수78목78        (5주 1일)
// ----------------------------------------------------------------
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 정렬
// ----------------------------------------------------------------
// 함수 overloading이 가능한 이유는 C++ compiler가 이름은 mangling 하기 때문
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	
	int a[3]{ 3,1,2 };

	qsort(a, sizeof(a) / sizeof(int), sizeof(int), [](const void* a, const void* b){
		return *(int*)b - *(int*)a; 
		});

	for (int n : a)
		std::cout << n << ' ';
	std::cout << std::endl;

	save("메인.cpp");
}



======================================
저장시간:2024-10-03 17:14:35.4352257
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.3 수         수78목78        (5주 1일)
// ----------------------------------------------------------------
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 정렬
// ----------------------------------------------------------------
// 함수 overloading이 가능한 이유는 C++ compiler가 이름은 mangling 하기 때문
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	
	int a[3]{ 3,1,2 };

	qsort(a, sizeof(a) / sizeof(int), sizeof(int), [](const void* a, const void* b) -> int {
		return *(int*)b - *(int*)a; 
		});

	for (int n : a)
		std::cout << n << ' ';
	std::cout << std::endl;

	save("메인.cpp");
}



======================================
저장시간:2024-10-03 17:15:51.1327176
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.3 수         수78목78        (5주 1일)
// ----------------------------------------------------------------
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 정렬
// ----------------------------------------------------------------
// 함수 overloading이 가능한 이유는 C++ compiler가 이름은 mangling 하기 때문
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
auto main() -> int 
//--------
{
	
	int a[3]{ 3,1,2 };

	qsort(a, sizeof(a) / sizeof(int), sizeof(int), [](const void* a, const void* b) -> int {
		return *(int*)a - *(int*)b; 
		});

	for (int n : a)
		std::cout << n << ' ';
	std::cout << std::endl;

	save("메인.cpp");
}



======================================
저장시간:2024-10-03 17:17:39.5564570
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.3 수         수78목78        (5주 1일)
// ----------------------------------------------------------------
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 정렬
// ----------------------------------------------------------------
// 함수 overloading이 가능한 이유는 C++ compiler가 이름은 mangling 하기 때문
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	
	int a[3]{ 3,1,2 };

	qsort(a, sizeof(a) / sizeof(int), sizeof(int), [](const void* a, const void* b) {
		return *(int*)a - *(int*)b; 
		});

	for (int n : a)
		std::cout << n << ' ';
	std::cout << std::endl;

	save("메인.cpp");
}



======================================
저장시간:2024-10-03 17:22:07.6724019
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.3 수         수78목78        (5주 1일)
// ----------------------------------------------------------------
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 정렬
// ----------------------------------------------------------------
// 함수 overloading이 가능한 이유는 C++ compiler가 이름은 mangling 하기 때문
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	[]() {
		std::cout << "안녕/ 난 lamda, b는 묵음이야" << std::endl;
		};

	save("메인.cpp");
}



======================================
저장시간:2024-10-03 17:22:47.5798205
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.3 수         수78목78        (5주 1일)
// ----------------------------------------------------------------
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 정렬
// ----------------------------------------------------------------
// 함수 overloading이 가능한 이유는 C++ compiler가 이름은 mangling 하기 때문
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	[]() {
		std::cout << "안녕/ 난 lamda, b는 묵음이야" << std::endl;
		}();

	save("메인.cpp");
}



======================================
저장시간:2024-10-03 17:22:55.8371577
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.3 수         수78목78        (5주 1일)
// ----------------------------------------------------------------
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 정렬
// ----------------------------------------------------------------
// 함수 overloading이 가능한 이유는 C++ compiler가 이름은 mangling 하기 때문
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	[]() {
		std::cout << "안녕? 난 lamda, b는 묵음이야" << std::endl;
		}();

	save("메인.cpp");
}



======================================
저장시간:2024-10-03 17:23:39.8468428
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.3 수         수78목78        (5주 1일)
// ----------------------------------------------------------------
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 정렬
// ----------------------------------------------------------------
// 함수 overloading이 가능한 이유는 C++ compiler가 이름은 mangling 하기 때문
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	[]() {
		std::cout << "안녕? 난 lamda, b는 묵음이야" << std::endl;
		}();	// 마지막 ()는 람다 호출

	save("메인.cpp");
}



======================================
저장시간:2024-10-03 17:24:18.8035278
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.3 수         수78목78        (5주 1일)
// ----------------------------------------------------------------
// 10.9(수) - 강의실 수업
// ----------------------------------------------------------------
// 정렬
// ----------------------------------------------------------------
// 함수 overloading이 가능한 이유는 C++ compiler가 이름은 mangling 하기 때문
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	[]() {
		std::cout << "안녕? 난 lamda, b는 묵음이야" << std::endl;
		}();	// 마지막 ()는 함수 호출 연산자

	save("메인.cpp");
}



======================================
저장시간:2024-10-09 16:01:00.9319525
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.9 수         수78목78        (5주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// 동적할당 메모리 
// ----------------------------------------------------------------
// syntatic, sugar
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{

	save("메인.cpp");

	// [문제] 사용자가 숫자를 입력한 숫자만큼 int를 저장할 메모리를 확보하라.
	// 이 메모리를 1부터 시작하는 정수로 채워라.
	// 메모리에 저장된 모든 정수의 합을 화면에 출력하라. 

	while (true) {
		std::cout << "숫자를 입력하세요 - ";
		int num;
		std::cin >> num;
		
		int* p = new int[num];

		for (int i = 0; i < num; ++i) 
			p[i] = i + 1;
		
		int sum{};
		for (int i = 0; i < num; ++i)
			sum += p[i];

		std::cout << "1부터" << num << " 까지의 합계 -" << sum << std::endl;

	}

	
}



======================================
저장시간:2024-10-09 16:14:10.4975637
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.9 수         수78목78        (5주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// 동적할당 메모리 
// ----------------------------------------------------------------
// syntatic, sugar
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");

	// [문제] 동적할당으로 얻을 수 있는 가장 큰 메모리는
	// 이 메모리는 contiguous 하다.
	
	new char[1'000'000'000];

	std::cout << "문제 없이 할당됨";
	

	
}



======================================
저장시간:2024-10-09 16:18:18.5297156
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.9 수         수78목78        (5주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// 동적할당 메모리 
// ----------------------------------------------------------------
// syntatic, sugar
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");

	// [문제] 동적할당으로 얻을 수 있는 가장 큰 메모리는
	// 이 메모리는 contiguous 하다.
	
	new char[39'999'999'999];

	std::cout << "문제 없이 할당됨";
	

	
}



======================================
저장시간:2024-10-09 16:20:02.0495605
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.9 수         수78목78        (5주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// 동적할당 메모리 
// ----------------------------------------------------------------
// syntatic, sugar
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");

	// [문제] 동적할당으로 얻을 수 있는 가장 큰 메모리는
	// 이 메모리는 contiguous 하다.
	
	new char[39'000'000'000];

	std::cout << "문제 없이 할당됨";
	

	
}



======================================
저장시간:2024-10-09 16:29:28.6725903
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.9 수         수78목78        (5주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// 동적할당 메모리 
// ----------------------------------------------------------------
// syntatic, sugar
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");

	// [문제] 동적할당으로 얻을 수 있는 가장 큰 메모리는
	// 이 메모리는 contiguous 하다.
	
	new char[39'999'999'999];

	std::cout << "문제 없이 할당됨";
	

	
}



======================================
저장시간:2024-10-09 16:30:04.8300458
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.9 수         수78목78        (5주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// 동적할당 메모리 
// ----------------------------------------------------------------
// syntatic, sugar
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");

	// [문제] 동적할당으로 얻을 수 있는 가장 큰 메모리는
	// 이 메모리는 contiguous 하다.
	
	new char[39'999'999'989];

	std::cout << "문제 없이 할당됨";
	

	
}



======================================
저장시간:2024-10-09 16:42:03.6254544
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.9 수         수78목78        (5주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// 동적할당 메모리 
// ----------------------------------------------------------------
// syntatic, sugar
// ----------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"

using namespace std;

//--------
int main()
//--------
{
	save("메인.cpp");

	// 메모리를 계속 요청한다면?

	int cnt{};
	while (true) {
		new char[2'000'000'000];
		cout << ++cnt << " - 메모리 할당 성공" << endl;

		this_thread::sleep_for(2s); 
	}

}



======================================
저장시간:2024-10-09 16:44:07.7046250
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.9 수         수78목78        (5주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// 동적할당 메모리 
// ----------------------------------------------------------------
// syntatic, sugar
// ----------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"

using namespace std;

//--------
int main()
//--------
{
	save("메인.cpp");

	// 메모리를 계속 요청한다면?

	int cnt{};
	while (true) {
		char* p = new char[2'000'000'000];
		cout << ++cnt << " - 메모리 할당 성공" << endl;

		this_thread::sleep_for(2s); 

		delete[] p;		// 사용한 자원은 반환하여야 한다
	}

}



======================================
저장시간:2024-10-09 16:45:04.6195924
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.9 수         수78목78        (5주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// 동적할당 메모리 
// ----------------------------------------------------------------
// syntatic, sugar
// ----------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"

using namespace std;

//--------
int main()
//--------
{
	save("메인.cpp");

	// 메모리를 계속 요청한다면?

	int cnt{};
	while (true) {
		char* p = new char[2'000'000'000];
		cout << ++cnt << " - 메모리 할당 성공" << endl;

		this_thread::sleep_for(0.1s); 

		delete[] p;		// 사용한 자원은 반환하여야 한다
	}

}



======================================
저장시간:2024-10-09 16:53:01.9071269
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.9 수         수78목78        (5주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// 동적할당 메모리 
// ----------------------------------------------------------------
// syntatic, sugar
// ----------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"

using namespace std;

//--------
int main()
//--------
{
	save("메인.cpp");

	// 메모리를 계속 요청한다면?

	int cnt{};
	while (true) {
		// 메모리 요청은 실패할 수있다.
		// 실패시 메모리 관리자는 예외를 던진다.
		// 이 예외를 처리하지 않으면 프로그램은 비정상 종료한다.

		
		try{
			char* p = new char[2'000'000'000];
		}
		catch ( exception& e ) {
			cout << e.what() << endl;
			break;
		}
		cout << ++cnt << " - 메모리 할당 성공" << endl;
	}

}



======================================
저장시간:2024-10-09 16:57:40.3803429
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.9 수         수78목78        (5주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// C++ 실행파일의 메모리 - STACK, DATA, free store, CODE
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

char c[1'000'000'000];

//--------
int main()
//--------
{
	save("메인.cpp");

	for (int i = 0; i < 10; ++i)
		std::cout << c[i] + 7 <<std::endl;
}



======================================
저장시간:2024-10-09 16:58:13.6443409
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.9 수         수78목78        (5주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// C++ 실행파일의 메모리 - STACK, DATA, free store, CODE
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

char c[1'000'000'000];

//--------
int main()
//--------
{
	save("메인.cpp");

	for (int i = 0; i < 10; ++i)
		std::cout << (char)c[i] + 7 <<std::endl;
}



======================================
저장시간:2024-10-09 16:59:13.4923971
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.9 수         수78목78        (5주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// C++ 실행파일의 메모리 - STACK, DATA, free store, CODE
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

char c[1'000'000'000];

//--------
int main()
//--------
{
	save("메인.cpp");

	for (int i = 0; i < 10; ++i)
		std::cout << (char)(c[i] + 7) <<std::endl;
}



======================================
저장시간:2024-10-09 17:16:58.4024308
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.9 수         수78목78        (5주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// C++ 실행파일의 메모리 - STACK, DATA, free store, CODE
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

int add(int, int);
//--------
int main()
//--------
{
	(*save)( "메인.cpp" );	// 함수에 *를 붙혀 호출하는 것이 정석

	int num{ 123 };
	int* p = &num;

// fp = add;	// 내일
}

int add(int a, int b)
{
	return a + b;
}

======================================
저장시간:2024-10-09 17:18:15.6414670
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.9 수         수78목78        (5주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// C++ 실행파일의 메모리 - STACK, DATA, free store, CODE
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

int add(int, int);
//--------
int main()
//--------
{
	(*save)( "메인.cpp" );	// 함수에 *를 붙혀 호출하는 것이 정석

	int num{ 123 };
	int* p = &num;

	std::cout << "add의 타입 - " << typeid(add).name() << std::endl;
// fp = add;	// 내일
}

int add(int a, int b)
{
	return a + b;
}

======================================
저장시간:2024-10-09 17:18:48.1827640
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.9 수         수78목78        (5주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// C++ 실행파일의 메모리 - STACK, DATA, free store, CODE
// ----------------------------------------------------------------
// 공부 - 함수포인터 읽어보기
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

int add(int, int);
//--------
int main()
//--------
{
	(*save)( "메인.cpp" );	// 함수에 *를 붙혀 호출하는 것이 정석

	int num{ 123 };
	int* p = &num;

	std::cout << "add의 타입 - " << typeid(add).name() << std::endl;
// fp = add;	// 내일
}

int add(int a, int b)
{
	return a + b;
}

======================================
저장시간:2024-10-10 15:40:17.5271266
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 목         수78목78        (6주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// C++ 실행파일의 메모리 - STACK, DATA, free store, CODE
// ----------------------------------------------------------------
// 공부 - 함수포인터 읽어보기
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	save( "메인.cpp" );	
	
	int* p;

	p = new int[1'0000];		// 1. 자원을 확보

	// 2. 자원을 활용
	p[3333] = 333;
	std::cout << p[3333] << std::endl;
								
	// 3. 자원을 반환
	delete[] p;
}


======================================
저장시간:2024-10-10 15:46:23.8428912
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 목         수78목78        (6주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// C++ 실행파일의 메모리 - STACK, DATA, free store, CODE
// ----------------------------------------------------------------
// 공부 - 함수포인터 읽어보기
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	save( "메인.cpp" );	
	
	int* p;

	p = new int[1'0000];		// 1. 자원을 확보

	// 2. 자원을 활용
	p[3333] = 333;
	std::cout << p[3333] << std::endl;
								
	delete[] p;			// 3. 자원을 반환

	delete[] p;

}


======================================
저장시간:2024-10-10 15:46:58.2769331
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 목         수78목78        (6주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// C++ 실행파일의 메모리 - STACK, DATA, free store, CODE
// ----------------------------------------------------------------
// 공부 - 함수포인터 읽어보기
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

//--------
int main()
//--------
{
	save( "메인.cpp" );	
	
	int* p;

	p = new int[1'0000];		// 1. 자원을 확보

	// 2. 자원을 활용
								
	delete[] p;			// 3. 자원을 반환

	delete[] p;

}


======================================
저장시간:2024-10-10 16:02:27.1182878
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 목         수78목78        (6주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// C++ 실행파일의 메모리 - STACK, DATA, free store, CODE
// ----------------------------------------------------------------
// 공부 - 함수포인터 읽어보기
// ----------------------------------------------------------------

#include <iostream>
#include <memory>
#include "save.h"

//--------
int main()
//--------
{
	save( "메인.cpp" );	
	
	//int* p;					// raw pointer - (실력이 된다면) 사용금지

	std::unique_ptr<int> p{ new int[10] };		// RAII
	
}


======================================
저장시간:2024-10-10 16:11:35.5217107
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 목         수78목78        (6주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// C++ 실행파일의 메모리 - STACK, DATA, free store, CODE
// ----------------------------------------------------------------
// 공부 - 함수포인터 읽어보기
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

int add(int, int);
int sub(int, int);

// 함수의 이름은 무엇인가요?
// 함수는 실행 파일의 CODE segement에 기록되어 있다.
// 기록된 메모리의 시간번지가 바로 함수의 이름이다.
 

//--------
int main()
//--------
{
	save( "메인.cpp" );	
	
	int(* fp)(int, int) = add;
	
	std::cout << (*fp)(3, 4) << std::endl;
}

int add(int a, int b)
{
	return a + b;
}

int sub(int a, int b)
{
	return a - b;
}

======================================
저장시간:2024-10-10 16:15:19.4628087
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 목         수78목78        (6주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// C++ 실행파일의 메모리 - STACK, DATA, free store, CODE
// ----------------------------------------------------------------
// 공부 - 함수포인터 읽어보기
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

int add(int, int);
int sub(int, int);

// 함수의 이름은 무엇인가요?
// 함수는 실행 파일의 CODE segement에 기록되어 있다.
// 기록된 메모리의 시간번지가 바로 함수의 이름이다.
 

//--------
int main()
//--------
{
	save( "메인.cpp" );	
	
	int(* fp)(int, int) = add;
	
	std::cout << (*fp)(3, 4) << std::endl;

	fp = sub;

	std::cout << (*fp)(3, 4) << std::endl;
}

int add(int a, int b)
{
	return a + b;
}

int sub(int a, int b)
{
	return a - b;
}

======================================
저장시간:2024-10-10 16:32:01.3195606
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 목         수78목78        (6주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// C++ 실행파일의 메모리 - STACK, DATA, free store, CODE
// ----------------------------------------------------------------
// 공부 - 함수포인터 읽어보기
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

char c[1'500'000'000];

//--------
int main()
//--------
{
	save( "메인.cpp" );	
	
	// [문제] 실행결과를 해석하라

	for (int i = 0; i < 10; ++i)
		std::cout << c[i] << std::endl;
}



======================================
저장시간:2024-10-10 16:36:21.9208611
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 목         수78목78        (6주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// C++ 실행파일의 메모리 - STACK, DATA, free store, CODE
// ----------------------------------------------------------------
// 공부 - 함수포인터 읽어보기
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

char c[1'500'000'000];

//--------
int main()
//--------
{
	save( "메인.cpp" );	
	
	// [문제] 실행결과를 해석하라

	for (int i = 0; i < 1000; ++i)
		std::cout << (char)(c[i]+7) << " ";
}



======================================
저장시간:2024-10-10 16:41:49.9023545
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 목         수78목78        (6주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// C++ 실행파일의 메모리 - STACK, DATA, free store, CODE
// ----------------------------------------------------------------
// 공부 - 함수포인터 읽어보기
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

char c[1'500'000'000]{ 'A','B','C' };

//--------
int main()
//--------
{
	save( "메인.cpp" );	
	
	// [문제] 실행결과를 해석하라

	for (int i = 0; i < 10; ++i)
		std::cout << (char)c[i];
}



======================================
저장시간:2024-10-10 16:55:34.1584884
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 목         수78목78        (6주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

//--------
int main()
//--------
{
	save( "메인.cpp" );	
	
	std::ofstream out{ "int 100개" };		//RAII
	// 자동 close 되기 때문에 out.close( ); 사용X

	
}



======================================
저장시간:2024-10-10 16:56:02.7834721
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 목         수78목78        (6주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

//--------
int main()
//--------
{
	save( "메인.cpp" );	
	
	std::ofstream out{ "int 100개" };		//RAII
	
	for (int i = 0; i < 100; ++i)
		std::cout << i;
	
}



======================================
저장시간:2024-10-10 16:56:54.9266232
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 목         수78목78        (6주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

//--------
int main()
//--------
{
	save( "메인.cpp" );	
	
	std::ofstream out{ "int 100개" };		//RAII
	
	for (int i = 0; i < 100; ++i)
		std::cout << i+1;
	
}



======================================
저장시간:2024-10-10 16:57:51.8623387
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 목         수78목78        (6주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

//--------
int main()
//--------
{
	save( "메인.cpp" );	
	
	std::ofstream out{ "int 100개" };		//RAII
	
	for (int i = 0; i < 100; ++i)
		std::cout << i+1 << " ";
	
}



======================================
저장시간:2024-10-10 16:59:01.0396822
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 목         수78목78        (6주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

//--------
int main()
//--------
{
	save( "메인.cpp" );	
	
	std::ofstream out{ "int 100개" };		//RAII
	
	for (int i = 0; i < 100; ++i)
		out << i+1 << " ";
	
}



======================================
저장시간:2024-10-10 17:14:53.9131580
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 목         수78목78        (6주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 확장자는 파일의 형식에 대한 힌트 -> 실제 파일 형식을 결정하지는 않음
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

//--------
int main()
//--------
{
	save( "메인.cpp" );	
	
	// [문제] 여러분의 폴더에는 "int 100개"라는 파일이 있다.
	// 이 파일에는 int값 100개가 문자 형식으로 기록되어 있다.
	// int값은 공백으로 분리되어 있다.
	// 파일에 있는 int값을 읽어 화면에 출력하라.

	int j;

	std::ifstream in{ "int 100개" };
	for (int i = 0; i < 100; ++i) {
		in >> j;
		std::cout << j << " ";
	}

	
}



======================================
저장시간:2024-10-10 17:21:00.6559932
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 목         수78목78        (6주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 확장자는 파일의 형식에 대한 힌트 -> 실제 파일 형식을 결정하지는 않음
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

//--------
int main()
//--------
{
	save( "메인.cpp" );	
	
	// [문제] 여러분의 폴더에는 "int 100개"라는 파일이 있다.
	// 이 파일에는 int값 100개가 문자 형식으로 기록되어 있다.
	// int값은 공백으로 분리되어 있다.
	// 파일에 있는 int값을 읽어 화면에 출력하라.

	std::ifstream in{ "int 100개" };
	int num;
	in >> num;	// in은 고급 입출력이기에 빈칸을 자동으로 생략 후 인식함
	
}



======================================
저장시간:2024-10-16 15:40:43.8618363
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 수         수78목78        (6주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

//--------
int main()
//--------
{
	save( "메인.cpp" );	
	
	// [문제] 여러분의 폴더에는 "int 100개"라는 파일이 있다.
	// 이 파일에는 int값 100개가 문자 형식으로 기록되어 있다.
	// int값은 공백으로 분리되어 있다.
	// 파일에 있는 int값을 읽어 화면에 출력하라.

	std::ifstream in{ "int 100개" };
	if (not in) {
		std::cout << "파일을 읽을 수 없습니다" << std::endl;
		exit(111);					// exit(111); main이 아닌 함수에서 빠져나올 때 사용 
	}
	int num;				//읽은 값을 저장할 메모리
	in >> num;	// in은 고급 입출력이기에 빈칸을 자동으로 생략 후 인식함	// in이 파일에서 읽은 값을 num에 저장
	std::cout << "읽은 숫자 - " << num << std::endl;
}



======================================
저장시간:2024-10-16 15:42:15.6584388
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 수         수78목78        (6주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

//--------
int main()
//--------
{
	save( "메인.cpp" );	
	
	// [문제] 여러분의 폴더에는 "int 100개"라는 파일이 있다.
	// 이 파일에는 int값 100개가 문자 형식으로 기록되어 있다.
	// int값은 공백으로 분리되어 있다.
	// 파일에 있는 int값을 읽어 화면에 출력하라.

	std::ifstream in{ "int 100개" };
	if (not in) {
		std::cout << "파일을 읽을 수 없습니다" << std::endl;
		exit(111);					// exit(111); main이 아닌 함수에서 빠져나올 때 사용 
	}
	int num;				//읽은 값을 저장할 메모리

	for(int i=0;i<100;++i){
		in >> num;	// in은 고급 입출력이기에 빈칸을 자동으로 생략 후 인식함	// in이 파일에서 읽은 값을 num에 저장
		std::cout << num << " - ";
	}
}



======================================
저장시간:2024-10-16 15:47:05.5574352
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 수         수78목78        (6주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"

std::default_random_engine dre;
std::uniform_int_distribution uid;

//--------
int main()
//--------
{
	save("메인.cpp");
	
	int num = uid(dre);

	std::ofstream out{ "랜덤값 몇개.mp3" };
	for (int i = 0; i < num; ++i)
		out << uid(dre) << " ";
}



======================================
저장시간:2024-10-16 15:47:36.4099726
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 수         수78목78        (6주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"

std::default_random_engine dre;
std::uniform_int_distribution uid;

//--------
int main()
//--------
{
	save("메인.cpp");
	
	int num = uid(dre);
	num %= 1'0000;

	std::ofstream out{ "랜덤값 몇개.mp3" };
	for (int i = 0; i < num; ++i)
		out << uid(dre) << " ";
}



======================================
저장시간:2024-10-16 15:55:13.8627544
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 수         수78목78        (6주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"

//--------
int main()
//--------
{
	//save("메인.cpp");
	
	// [문제] 파일 "랜덤값 몇개.mp3"에는 몇 개인지 모르는 int 값이 저장되어 있다.
	// 모두 몇 개인지 출력하라.
	// 가장 큰 값을 찾아 화면에 출력하라.

	std::ifstream in{ "랜덤값 몇개" };
	if (not in) {
		std::cout << "파일을 읽을 수 없습니다." << std::endl;
		exit(111);
	}
	int num;
	int count{};
	for (int i = 0; i < num; ++i;) {
		in >> num;
		++count;
	}
	std::cout << count << "개" << std::endl;

}



======================================
저장시간:2024-10-16 15:55:24.2262619
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 수         수78목78        (6주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"

//--------
int main()
//--------
{
	//save("메인.cpp");
	
	// [문제] 파일 "랜덤값 몇개.mp3"에는 몇 개인지 모르는 int 값이 저장되어 있다.
	// 모두 몇 개인지 출력하라.
	// 가장 큰 값을 찾아 화면에 출력하라.

	std::ifstream in{ "랜덤값 몇개" };
	if (not in) {
		std::cout << "파일을 읽을 수 없습니다." << std::endl;
		exit(111);
	}
	int num;
	int count{0 };
	for (int i = 0; i < num; ++i;) {
		in >> num;
		++count;
	}
	std::cout << count << "개" << std::endl;

}



======================================
저장시간:2024-10-16 16:06:05.9345707
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 수         수78목78        (6주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");
	
	// [문제] 파일 "랜덤값 몇개.mp3"에는 몇 개인지 모르는 int 값이 저장되어 있다.
	// 모두 몇 개인지 출력하라.
	// 가장 큰 값을 찾아 화면에 출력하라.

	std::ifstream in{"랜덤값 몇개.mp3"};
	if (not in) {
		std::cout << "파일을 읽을 수 없습니다." << std::endl;
		exit(111);
	}
	int num;
	int count{ 0 };
	
	while (in >> num)
		++count;
	
	std::cout << count << "개" << std::endl;

}



======================================
저장시간:2024-10-16 16:21:48.4483057
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 수         수78목78        (6주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

//--------
int main()
//--------
{
	//save("메인.cpp");
	
	// [문제] 파일 "랜덤값 몇개.mp3"에는 몇 개인지 모르는 int 값이 저장되어 있다.
	// 모두 몇 개인지 출력하라.
	// 가장 큰 값을 찾아 화면에 출력하라.

	std::ifstream in{"랜덤값 몇개.mp3"};
	if (not in) {
		std::cout << "파일을 읽을 수 없습니다." << std::endl;
		exit(111);
	}
	int num;
	
	int cnt{};
	int maxVal{ std::numeric_limits<int>::min() };

	while (in >> num){
		std::cout << num << "***";
		++cnt;
		if (maxval < num)
			maxVal = num;
	}

	
	std::cout << std::endl;
	std::cout << "모두" << cnt << "개의 int값을 읽었다" << std::endl;

}



======================================
저장시간:2024-10-16 16:23:07.5270409
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 수         수78목78        (6주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

//--------
int main()
//--------
{
	//save("메인.cpp");
	
	// [문제] 파일 "랜덤값 몇개.mp3"에는 몇 개인지 모르는 int 값이 저장되어 있다.
	// 모두 몇 개인지 출력하라.
	// 가장 큰 값을 찾아 화면에 출력하라.

	std::ifstream in{"랜덤값 몇개.mp3"};
	if (not in) {
		std::cout << "파일을 읽을 수 없습니다." << std::endl;
		exit(111);
	}
	int num;
	
	int cnt{};
	int maxVal{ std::numeric_limits<int>::min() };

	while (in >> num){
		std::cout << num << "***";
		++cnt;
		if (maxval < num)
			maxVal = num;
	}

	
	std::cout << std::endl;
	std::cout << "모두" << cnt << "개의 int값을 읽었다" << std::endl;

}



======================================
저장시간:2024-10-16 16:25:30.9770077
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 수         수78목78        (6주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");
	
	// [문제] 파일 "랜덤값 몇개.mp3"에는 몇 개인지 모르는 int 값이 저장되어 있다.
	// 모두 몇 개인지 출력하라.
	// 가장 큰 값을 찾아 화면에 출력하라.

	std::ifstream in{"랜덤값 몇개.mp3"};
	if (not in) {
		std::cout << "파일을 읽을 수 없습니다." << std::endl;
		exit(111);
	}
	int num;
	
	int cnt{};
	int maxVal{ std::numeric_limits<int>::min() };

	while (in >> num){
		std::cout << num << "***";
		++cnt;
		if (maxVal < num)
			maxVal = num;
	}
	std::cout << std::endl;
	std::cout << "최댓값 - " << maxVal << std::endl;
	std::cout << "모두" << cnt << "개의 int값을 읽었다" << std::endl;

}



======================================
저장시간:2024-10-16 16:25:56.8952193
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 수         수78목78        (6주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");
	
	// [문제] 파일 "랜덤값 몇개.mp3"에는 몇 개인지 모르는 int 값이 저장되어 있다.
	// 모두 몇 개인지 출력하라.
	// 가장 큰 값을 찾아 화면에 출력하라.

	std::ifstream in{"랜덤값 몇개.mp3"};
	if (not in) {
		std::cout << "파일을 읽을 수 없습니다." << std::endl;
		exit(111);
	}
	int num;
	
	int cnt{};
	int maxVal{ std::numeric_limits<int>::min() };

	while (in >> num){
		++cnt;
		if (maxVal < num)
			maxVal = num;
	}
	std::cout << std::endl;
	std::cout << "최댓값 - " << maxVal << std::endl;
	std::cout << "모두" << cnt << "개의 int값을 읽었다" << std::endl;

}



======================================
저장시간:2024-10-16 16:38:50.5981828
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 수         수78목78        (6주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

//--------
int main()
//--------
{
	//save("메인.cpp");
	
	// [문제] 파일 "랜덤값 몇개.mp3"에는 몇 개인지 모르는 int 값이 저장되어 있다.
	// 오름차순 정렬하여 화면 출력하라.
	// 가장 큰 값을 찾아 화면에 출력하라.

	std::ifstream in{"랜덤값 몇개.mp3"};
	if (not in) {
		std::cout << "파일을 읽을 수 없습니다." << std::endl;
		exit(111);
	}
	int num;
	
	int cnt{};
	int maxVal{ std::numeric_limits<int>::min() };

	int a[cnt];
	qsort(a, sizeof(a) / sizeof(int), sizeof(int), [](const void* a, const void* b) {
		return *(int*)a - *(int*)b;
		});

	while (in >> num){
		std::cout << a;
		++cnt;
		if (maxVal < num)
			maxVal = num;
	}
	std::cout << std::endl;
	std::cout << "최댓값 - " << maxVal << std::endl;
	//std::cout << "모두" << cnt << "개의 int값을 읽었다" << std::endl;
}



======================================
저장시간:2024-10-16 16:49:10.9396689
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 수         수78목78        (6주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <print>
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");
	
	// [문제] 파일 "랜덤값 몇개.mp3"에는 몇 개인지 모르는 int 값이 저장되어 있다.
	// 오름차순 정렬하여 화면 출력하라.
	// 가장 큰 값을 찾아 화면에 출력하라.

	int cnt{};

	{
		std::ifstream in{ "랜덤값 몇개.mp3" };
		if (not in) {
			return 10101;
		}

		int num;
		while (in >> num)
			++cnt;
	}
	
	std::ifstream in{ "랜덤값 몇개.mp3" };

	int* p = new int[cnt];
	for (int i = 0; i < cnt; ++i)
		in >> p[i];

	qsort(p, cnt, sizeof(int), [](const void* a, const void* b) {
		return *(int*)a - *(int*)b;
		});

	for (int i = 0; i < cnt; ++i)
		std::print("{:16}", p[i]);
	
}



======================================
저장시간:2024-10-16 17:08:11.2626645
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 수         수78목78        (6주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");
	
	// [문제] 파일 "메인.cpp"에 사용된 알파벳 소문자의 개수를 출력하라.
	// 출력 예
	// a - 10
	// b - 2
	// 중략
	// z
	
	std::ifstream in{ "메인.cpp" };
	if (not in)
		return 9;

	char c;

	int alCnt[26]{};
	while (in >> c) {
		// c가 소문자라면 개수를 센다.
		if (islower(c)) {
			alCnt[c - 'a']++;
		}
	}
	for (int i = 0; i < 26; ++i)
		std::cout << 'a' + i << " - " << alCnt[i] << std::endl;

}



======================================
저장시간:2024-10-16 17:09:36.9277221
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 수         수78목78        (6주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");
	
	// [문제] 파일 "메인.cpp"에 사용된 알파벳 소문자의 개수를 출력하라.
	// 출력 예
	// a - 10
	// b - 2
	// 중략
	// z
	
	std::ifstream in{ "메인.cpp" };
	if (not in)
		return 9;

	char c;

	int alCnt[26]{};
	while (in >> c) {
		// c가 소문자라면 개수를 센다.
		if (islower(c)) {
			alCnt[c - 'a']++;
		}
	}
	for (int i = 0; i < 26; ++i)
		std::cout << static_cast<char>('a' + i) << " - " << alCnt[i] << std::endl;		// static_cast<char> 사용 -> int인 i가 4바이트 이기에 char인 a가 int로 바뀜

}



======================================
저장시간:2024-10-16 17:09:53.0348229
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 수         수78목78        (6주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// a
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");
	
	// [문제] 파일 "메인.cpp"에 사용된 알파벳 소문자의 개수를 출력하라.
	// 출력 예
	// a - 10
	// b - 2
	// 중략
	// z
	
	std::ifstream in{ "메인.cpp" };
	if (not in)
		return 9;

	char c;

	int alCnt[26]{};
	while (in >> c) {
		// c가 소문자라면 개수를 센다.
		if (islower(c)) {
			alCnt[c - 'a']++;
		}
	}
	for (int i = 0; i < 26; ++i)
		std::cout << static_cast<char>('a' + i) << " - " << alCnt[i] << std::endl;		// static_cast<char> 사용 -> int인 i가 4바이트 이기에 char인 a가 int로 바뀜

}



======================================
저장시간:2024-10-16 17:18:58.3153050
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 수         수78목78        (6주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");
	
	// [문제] 파일 "메인.cpp"의 소문자를 모두 대문자로 바꿔
	// "메인대문자.cpp"에 저장하라.

	std::ifstream in{ "메인.cpp" };
	if (not in)
		return 12121;

	std::ofstream out{ "메인대문자.cpp" };

	char ch;
	while (in >> ch){
		ch = toupper(ch);
		out << ch;
	}

		

}



======================================
저장시간:2024-10-16 17:19:32.2248435
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.10 수         수78목78        (6주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간 시험 예상
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");
	
	// [문제] 파일 "메인.cpp"의 소문자를 모두 대문자로 바꿔
	// "메인대문자.cpp"에 저장하라.

	std::ifstream in{ "메인.cpp" };
	if (not in)
		return 12121;

	std::ofstream out{ "메인대문자.cpp" };

	char ch;
	in >> std::noskipws;
	while (in >> ch){
		ch = toupper(ch);
		out << ch;
	}

		

}



======================================
저장시간:2024-10-17 15:50:52.3938198
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.17 목         수78목78        (7주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <string>
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");
	
	// [문제] 파일 "메인.cpp"에 있는 단어의 개수를 출력하라.
	// 단어는 공백으로 분리된 문자의 집합을 말한다.
	// C++언어에서 단어의 처리는 std::string을 사용하면 된다.

	std::ifstream in{ "메인.cpp" };
	if (not in)
		return 999;

	std::string str;
	int cnt{};

	while (in >> str)
		++cnt;

	std::cout << "모두" << cnt << "개의 단어가 있다" << std::endl;
}



======================================
저장시간:2024-10-17 15:51:55.9714220
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.17 목         수78목78        (7주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <string>
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");
	
	// [문제] 파일 "메인.cpp"에 있는 단어의 개수를 출력하라.
	// 단어는 공백으로 분리된 문자의 집합을 말한다.
	// C++언어에서 단어의 처리는 std::string을 사용하면 된다.

	std::ifstream in{ "메인.cpp" };
	if (not in)
		return 999;

	std::string str;
	int cnt{};

	while (in >> str){
		++cnt;
		std::cout << cnt << std::endl;
	}

	std::cout << "모두" << cnt << "개의 단어가 있다" << std::endl;
}



======================================
저장시간:2024-10-17 15:52:05.5355736
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.17 목         수78목78        (7주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <string>
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");
	
	// [문제] 파일 "메인.cpp"에 있는 단어의 개수를 출력하라.
	// 단어는 공백으로 분리된 문자의 집합을 말한다.
	// C++언어에서 단어의 처리는 std::string을 사용하면 된다.

	std::ifstream in{ "메인.cpp" };
	if (not in)
		return 999;

	std::string str;
	int cnt{};

	while (in >> str){
		++cnt;
		std::cout << in << std::endl;
	}

	std::cout << "모두" << cnt << "개의 단어가 있다" << std::endl;
}



======================================
저장시간:2024-10-17 15:52:22.3656436
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.17 목         수78목78        (7주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <string>
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");
	
	// [문제] 파일 "메인.cpp"에 있는 단어의 개수를 출력하라.
	// 단어는 공백으로 분리된 문자의 집합을 말한다.
	// C++언어에서 단어의 처리는 std::string을 사용하면 된다.

	std::ifstream in{ "메인.cpp" };
	if (not in)
		return 999;

	std::string str;
	int cnt{};

	while (in >> str){
		++cnt;
		std::cout << str << std::endl;
	}

	std::cout << "모두" << cnt << "개의 단어가 있다" << std::endl;
}



======================================
저장시간:2024-10-17 16:00:53.4604761
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.17 목         수78목78        (7주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <string>
#include "save.h"

//--------
int main()
//--------
{
	//save("메인.cpp");
	
	// [문제] 파일 "메인.cpp"에 있는 단어를 오름차순 정렬하여 출력하라.

	int cnt{};
	{
		std::ifstream in{ "메인.cpp" };
		if (not in)
			return 999;

		std::string str;

		while (in >> str) 
			++cnt;
	}

	std::string* p = new std::string [str] ;
	for (int i = 0; i < cnt; ++i)
		in >> p[i];

	qsort(p, cnt, sizeof(char), [](const void* a, const void* b) {
		return *(int*)a - *(int*)b;
		});
}



======================================
저장시간:2024-10-17 16:19:54.5596450
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.17 목         수78목78        (7주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <string>
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");
	
	// [문제] 파일 "메인.cpp"에 있는 단어를 오름차순 정렬하여 출력하라.

	int cnt{};
	{
		std::ifstream in{ "메인.cpp" };
		if (not in)
			return 999;

		std::string str;

		while (in >> str) 
			++cnt;
	}
	// 정렬
	std::string* p = new std::string[cnt];
	
	std::ifstream in{ "메인.cpp" };
	if (not in)
		return 999;

	for (int i = 0; i < cnt; ++i)
		in >> p[i];

	qsort(p, cnt, sizeof(std::string), [](const void* a, const void* b) {
		std::string s = *(std::string*)a;
		std::string t = *(std::string*)b;
		
		if (s < t)
			return -1;
		else if (s > t)
			return 1;
		return 0;

		});

	// p에 있는 string 출력
	for (int i = 0; i < cnt; ++i)
		std::cout << p[i] << std::endl;

	delete[] p;
}



======================================
저장시간:2024-10-17 16:21:39.6519123
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.17 목         수78목78        (7주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// FILE I/O
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <string>
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");
	
	// [문제] 파일 "메인.cpp"에 있는 단어를 길이별로 정렬하여 출력하라.

	int cnt{};
	{
		std::ifstream in{ "메인.cpp" };
		if (not in)
			return 999;

		std::string str;

		while (in >> str) 
			++cnt;
	}
	// 정렬
	std::string* p = new std::string[cnt];
	
	std::ifstream in{ "메인.cpp" };
	if (not in)
		return 999;

	for (int i = 0; i < cnt; ++i)
		in >> p[i];

	qsort(p, cnt, sizeof(std::string), [](const void* a, const void* b) {
		std::string s = *(std::string*)a;
		std::string t = *(std::string*)b;
		
		return static_cast<int>(s.length() - t.length());
		});

	// p에 있는 string 출력
	for (int i = 0; i < cnt; ++i)
		std::cout << p[i] << std::endl;

	delete[] p;
}



======================================
저장시간:2024-10-17 16:58:19.5126584
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.17 목         수78목78        (7주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// 사용자 정의 자료형
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

// struct와 class를 사용하여 세 자료형을 만든다.
// struct는 마음껏 바꿀 수 있지만 설재혁 -> 개재혁	// class는 그것을 허용하지 않는다.

class Person {
private;
	std::string name{ "설재혁" };
};

struct Dog {		
public		// struct default
	std::string name;
	int age;
	int kind;
	char color;
	
	void bark() {};
	void run() {};
};

//--------
int main()
//--------
{
	save("메인.cpp");
	
	Person p;

	p.name = "개재혁"
	std::cout << p.name << std::endl;
}



======================================
저장시간:2024-10-17 17:04:42.1426106
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.17 목         수78목78        (7주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// 사용자 정의 자료형
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

// struct와 class를 사용하여 세 자료형을 만든다.
// struct는 마음껏 바꿀 수 있지만 설재혁 -> 개재혁	// class는 그것을 허용하지 않는다.

class Person {
	std::string name{ "설재혁" };
};

struct Dog {		
	char c;
	int n;
};

//--------
int main()
//--------
{
	save("메인.cpp");
	
	Dog d;
	std::cout << "Dog의 크기 - " << sizeof(d) << std::endl;
}



======================================
저장시간:2024-10-17 17:05:11.5265926
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.17 목         수78목78        (7주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// 사용자 정의 자료형
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

// struct와 class를 사용하여 세 자료형을 만든다.
// struct는 마음껏 바꿀 수 있지만 설재혁 -> 개재혁	// class는 그것을 허용하지 않는다.

class Person {
	std::string name{ "설재혁" };
};

struct Dog {	
	int n;
	char c;
};

//--------
int main()
//--------
{
	save("메인.cpp");
	
	Dog d;
	std::cout << "Dog의 크기 - " << sizeof(d) << std::endl;
}



======================================
저장시간:2024-10-17 17:18:14.0720200
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.17 목         수78목78        (7주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// 사용자 정의 자료형 - User - defined data type
// ----------------------------------------------------------------
// data padding - 메모리를 희생해서 속도를 얻는다.
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

// 2차원 점을 표현하는 사용자 정의 자료형

struct Point2D {
	int x;
	int y;
};


//--------
int main()
//--------
{
	save("메인.cpp");
	
	
}



======================================
저장시간:2024-10-17 17:19:23.5863370
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.17 목         수78목78        (7주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// 사용자 정의 자료형 - User - defined data type
// ----------------------------------------------------------------
// data padding - 메모리를 희생해서 속도를 얻는다.
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

// 2차원 점을 표현하는 사용자 정의 자료형

// 앞 글자는 무조건 대문자

struct Point2D {
	int x;
	int y;
};


//--------
int main()
//--------
{
	save("메인.cpp");
	
	
}



======================================
저장시간:2024-10-23 15:37:33.7209436
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.23 목         수78목78        (7주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// 사용자 정의 자료형 - User - defined data type
// ----------------------------------------------------------------
// data padding - 메모리를 희생해서 속도를 얻는다.
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

// 2차원 점을 표현하는 사용자 정의 자료형

// 앞 글자는 무조건 대문자

struct Point2D {
	int x;
	int y;
};


//--------
int main()
//--------
{
	save("메인.cpp");
	
	Point2D point{};

	std::cout << point.x << ", " << point.y << std::endl;
}



======================================
저장시간:2024-10-23 15:38:32.4379958
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.23 목         수78목78        (7주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// 사용자 정의 자료형 - User - defined data type
// ----------------------------------------------------------------
// data padding - 메모리를 희생해서 속도를 얻는다.
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

// 2차원 점을 표현하는 사용자 정의 자료형

// 앞 글자는 무조건 대문자

struct Point2D {
	int x;
	int y;
};


//--------
int main()
//--------
{
	save("메인.cpp");
	
	Point2D point{};

	std::cout << "(" << point.x << ", " << point.y << ")" << std::endl;
}



======================================
저장시간:2024-10-23 15:41:36.7720888
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.23 목         수78목78        (7주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// 사용자 정의 자료형 - User - defined data type
// ----------------------------------------------------------------
// data padding - 메모리를 희생해서 속도를 얻는다.
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

// 2차원 점을 표현하는 사용자 정의 자료형

// 앞 글자는 무조건 대문자

struct Point2D {
	// variable member
	int x;
	int y;

	// fumction member
	void show( ) {
		std::cout << "(" << x << ", " << y << ")" << std::endl;
	}
};


//--------
int main()
//--------
{
	save("메인.cpp");
	
	Point2D point{};

	point.show();

}



// ----------------------------------------------------------------
// 2024. 2학기 10.23 목         수78목78        (7주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// 사용자 정의 자료형 - User - defined data type
// ----------------------------------------------------------------
// data padding - 메모리를 희생해서 속도를 얻는다.
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

// 2차원 점을 표현하는 사용자 정의 자료형

// 앞 글자는 무조건 대문자

struct Point2D {
	// variable member
	int x;
	int y;

	// fumction member
	void show( ) {
		std::cout << "(" << x << ", " << y << ")" << std::endl;
	}
};


//--------
int main()
//--------
{
	save("메인.cpp");
	
	Point2D points[100];		// 실행 안됨

	for (Point2D point : points)
		point.show;		// show 뒤에 () 붙히면 될듯?

}


======================================
저장시간:2024-10-23 15:49:09.8068419
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.23 목         수78목78        (7주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// 사용자 정의 자료형 - User - defined data type
// ----------------------------------------------------------------
// 함수는 CODE 영역에 기록됨. main, show 
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

// 2차원 점을 표현하는 사용자 정의 자료형

// 앞 글자는 무조건 대문자

struct Point2D {
	// variable member
	int x;
	int y;

	// fumction member
	void show( ) {
		std::cout << "(" << x << ", " << y << ")" << std::endl;
	}
};


//--------
int main()
//--------
{
	save("메인.cpp");
	
	Point2D point{ 2024, 1023 };		// instancing (메모리에 생성)

	point.show();

}



======================================
저장시간:2024-10-23 15:52:01.5328759
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.23 목         수78목78        (7주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// 멤버함수에 전달되는 this
// ----------------------------------------------------------------
// 함수는 CODE 영역에 기록됨. main, show 
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

// 2차원 점을 표현하는 사용자 정의 자료형

// 앞 글자는 무조건 대문자

struct Point2D {
	// variable member
	int x;
	int y;

	// fumction member
	void show( ) {
		std::cout << "(" << this->x << ", " << this->y << ")" << std::endl;			// this->는 변태같은데? 이딴짓 하지마
	}
};


//--------
int main()
//--------
{
	save("메인.cpp");
	
	Point2D point{ 2024, 1023 };		// instancing (메모리에 생성)

	point.show();

}



======================================
저장시간:2024-10-23 15:55:00.1399202
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.23 목         수78목78        (7주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// 멤버함수에 전달되는 this
// ----------------------------------------------------------------
// 함수는 CODE 영역에 기록됨. main, show 
// ----------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"

// 2차원 점을 표현하는 사용자 정의 자료형

// 앞 글자는 무조건 대문자

std::default_random_engine dre;
std::uniform_int_distribution uid{ -99,99 };

struct Point2D {
	// variable member
	int x{ uid(dre) };
	int y{ uid(dre) };

	// fumction member
	void show( ) {
		std::cout << "(" << x << ", " << y << ")" << std::endl;			// this->는 변태같은데? 이딴짓 하지마
	}
};


//--------
int main()
//--------
{
	save("메인.cpp");
	
	Point2D points[100];		// instancing (메모리에 생성)

	for (Point2D point : points)
		point.show();

}



======================================
저장시간:2024-10-23 16:08:47.6724622
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.23 목         수78목78        (7주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// 멤버함수에 전달되는 this
// ----------------------------------------------------------------
// 함수는 CODE 영역에 기록됨. main, show 
// ----------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"

// 2차원 점을 표현하는 사용자 정의 자료형

// 앞 글자는 무조건 대문자

std::default_random_engine dre;
std::uniform_int_distribution uid{ -99,99 };

struct Point2D {
	// variable member
	int x{ uid(dre) };
	int y{ uid(dre) };

	// fumction member
	void show( ) {
		std::cout << "(" << x << ", " << y << ")" << std::endl;			// this->는 변태같은데? 이딴짓 하지마
	}
};


//--------
int main()
//--------
{
	save("메인.cpp");
	
	Point2D points[100];		// instancing (메모리에 생성)

	//for (Point2D point : points)
		//point.show();

	// [문제] (0,0)에서 반경 20미만의 점에 영향을 미치는 폭탄이 터졌다.
	// 이것의 영향을 받은 점들의 좌표를 화면에 출력하고 모두 몇개인지 출력하라.
	// root 값은 sqrt() 함수를 이용하여 구할 수 있다.
	int cnt{};
	for (Point2D point : points) {
		if (sqrt((point.x)* (point.x) + (point.y)*(point.y)) < 20){
			point.show();
			++cnt;
		}
	}
	std::cout << cnt << "개";
}



======================================
저장시간:2024-10-23 16:09:25.2517496
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.23 목         수78목78        (7주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// 멤버함수에 전달되는 this
// ----------------------------------------------------------------
// 함수는 CODE 영역에 기록됨. main, show 
// ----------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"

// 2차원 점을 표현하는 사용자 정의 자료형

// 앞 글자는 무조건 대문자

std::default_random_engine dre;
std::uniform_int_distribution uid{ -99,99 };

struct Point2D {
	// variable member
	int x{ uid(dre) };
	int y{ uid(dre) };

	// fumction member
	void show( ) {
		std::cout << "(" << x << ", " << y << ")" << std::endl;			// this->는 변태같은데? 이딴짓 하지마
	}
};


//--------
int main()
//--------
{
	save("메인.cpp");
	
	Point2D points[100];		// instancing (메모리에 생성)

	//for (Point2D point : points)
		//point.show();

	// [문제] (0,0)에서 반경 20미만의 점에 영향을 미치는 폭탄이 터졌다.
	// 이것의 영향을 받은 점들의 좌표를 화면에 출력하고 모두 몇개인지 출력하라.
	// root 값은 sqrt() 함수를 이용하여 구할 수 있다.
	int cnt{};
	for (Point2D point : points) {
		if (sqrt((point.x)* (point.x) + (point.y)*(point.y)) < 20){
			point.show();
			++cnt;
		}
	}
	std::cout << cnt << "개" << std::endl;
}



======================================
저장시간:2024-10-23 16:27:17.0493232
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.23 목         수78목78        (7주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// 멤버함수에 전달되는 this
// ----------------------------------------------------------------
// 함수는 CODE 영역에 기록됨. main, show 
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

struct Point2D {
	int x;
	int y;

	// 함수들 - special 함수 6가지
	Point2D() {			// default creator(ctor)
		x = 2024;
		y = 1023;
	}

	void show( ) {
		std::cout << "(" << x << ", " << y << ")" << std::endl;			
	}
};


//--------
int main()
//--------
{
	save("메인.cpp");
	
	Point2D p;

	p.show();
	
}


======================================
저장시간:2024-10-23 16:28:12.7317566
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.23 목         수78목78        (7주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// 멤버함수에 전달되는 this
// ----------------------------------------------------------------
// 함수는 CODE 영역에 기록됨. main, show 
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

struct Point2D {
	int x;
	int y;

	// 함수들 - special 함수 6가지
	Point2D() : x{ 2024 }, y{ 1023 } {			// default creator(ctor) <- 초기화
	}

	void show( ) {
		std::cout << "(" << x << ", " << y << ")" << std::endl;			
	}
};


//--------
int main()
//--------
{
	save("메인.cpp");
	
	Point2D p;

	p.show();
	
}


======================================
저장시간:2024-10-23 16:31:21.4871810
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.23 목         수78목78        (7주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// 멤버함수에 전달되는 this
// ----------------------------------------------------------------
// 함수는 CODE 영역에 기록됨. main, show 
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

struct Point2D {
	int x;
	int y;

	// 함수들 - special 함수 6가지
	Point2D() = default;		// 굳이 default 를 적지 않아도 생성자가 알아서 생성됨. 그래서 int x{}; 을 써도 0으로 초기화된다.

	void show( ) {
		std::cout << "(" << x << ", " << y << ")" << std::endl;			
	}
};


//--------
int main()
//--------
{
	save("메인.cpp");
	
	Point2D p;

	p.show();
	
}


======================================
저장시간:2024-10-23 16:47:16.5026985
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.23 목         수78목78        (7주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// 멤버함수에 전달되는 this
// ----------------------------------------------------------------
// 함수는 CODE 영역에 기록됨. main, show 
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

struct Dog {
	// 멤버 변수를 바깥에 공개하는 것이 좋으면 struct
	// 멤버 변수를 공개하지 않는 것이 맞다면 class
	
	std::string name{ "설재혁" };
	int age{ 20 };
};

//--------
int main()
//--------
{
	save("메인.cpp");
	
	Dog dog;

	std::cout << dog.name << std::endl;

	
}


======================================
저장시간:2024-10-23 16:48:05.1624038
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.23 목         수78목78        (7주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// 멤버함수에 전달되는 this
// ----------------------------------------------------------------
// 함수는 CODE 영역에 기록됨. main, show 
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

struct Dog {
	// 멤버 변수를 바깥에 공개하는 것이 좋으면 struct
	// 멤버 변수를 공개하지 않는 것이 맞다면 class
	
	std::string name{ "설재혁" };
	int age{ 20 };
};

//--------
int main()
//--------
{
	save("메인.cpp");
	
	Dog dog;

	dog.name = "개재혁";			// 밖에서 마음껏 바꿀 수 있다. -> public		// class 사용시 바꾸기 불가
	std::cout << dog.name << std::endl;

	
}


======================================
저장시간:2024-10-23 16:50:50.6856608
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.23 목         수78목78        (7주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// 멤버함수에 전달되는 this
// ----------------------------------------------------------------
// 함수는 CODE 영역에 기록됨. main, show 
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

class Dog {			
private:		// default access-modifier
	std::string name{ "설재혁" };
	int age{ 20 };
};

//--------
int main()
//--------
{
	save("메인.cpp");
	
	Dog dog;

	
	
}


======================================
저장시간:2024-10-23 17:02:50.3032807
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.23 목         수78목78        (7주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// 멤버함수에 전달되는 this
// ----------------------------------------------------------------
// 함수는 CODE 영역에 기록됨. main, show 
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include <Windows.h>
#include <mmsystem.h>
#include "save.h"

#pragma comment(lib,"winmm.lib")

class Dog {			
private:		// default access-modifier
	std::string name;
	int age;

public:
	Dog() {
		std::cout << "디폴트 생성자" << std::endl;
		PlaySound(L"개소리.wav", NULL, SND_SYNC);
	}
};

//--------
int main()
//--------
{
	save("메인.cpp");
	
	Dog dog;

	
	
}


======================================
저장시간:2024-10-23 17:07:34.2036416
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.23 목         수78목78        (7주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// 멤버함수에 전달되는 this
// ----------------------------------------------------------------
// 함수는 CODE 영역에 기록됨. main, show 
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include <Windows.h>
#include <mmsystem.h>
#include "save.h"

#pragma comment(lib,"winmm.lib")

class Dog {			
private:		// default access-modifier
	std::string name;
	int age;

public:
	Dog() {
		std::cout << "디폴트 생성자" << std::endl;
		PlaySound(L"개소리.wav", NULL, SND_SYNC);
	}
	~Dog() {
		std::cout << "디폴트 생성자" << std::endl;
		PlaySound(L"개소멸.wav", NULL, SND_SYNC);
	}
};

//--------
int main()
//--------
{
	save("메인.cpp");
	
	Dog dog[10];
}


======================================
저장시간:2024-10-23 17:09:37.5741724
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.23 목         수78목78        (7주 2일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// 멤버함수에 전달되는 this
// ----------------------------------------------------------------
// 함수는 CODE 영역에 기록됨. main, show 
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include <Windows.h>
#include <mmsystem.h>
#include "save.h"

#pragma comment(lib,"winmm.lib")

class Dog {			
private:		// default access-modifier
	std::string name;
	int age;

public:
	Dog() {
		std::cout << "디폴트 생성자" << std::endl;
		PlaySound(L"개소리.wav", NULL, SND_SYNC);
	}
	~Dog() {
		std::cout << "소멸자" << std::endl;
		PlaySound(L"개소멸.wav", NULL, SND_SYNC);
	}
};

//--------
int main()
//--------
{
	save("메인.cpp");
	
	{ // 지역객체의 life cycle
		Dog dog;
	}

	std::cout << "이미 소멸됨" << std::endl;
}


======================================
저장시간:2024-10-24 15:39:02.9933849
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 함수는 CODE 영역에 기록됨. main, show 
// ----------------------------------------------------------------

#include <iostream>    
#include <string>
#include <Windows.h>
#include <mmsystem.h>
#include "save.h"

#pragma comment(lib,"winmm.lib")

class Dog {			
private:		// default access-modifier
	std::string name;
	int age;

public:
	Dog() {
		std::cout << "디폴트 생성자" << std::endl;
		PlaySound(L"개소리.wav", NULL, SND_SYNC);
	}
	~Dog() {
		std::cout << "소멸자" << std::endl;
		PlaySound(L"개소멸.wav", NULL, SND_SYNC);
	}
};
                                                                                                 
//--------
int main()
//--------
{
	save("메인.cpp");
	
	Dog dog;

	std::cout << "메인 끝나기 전" << std::endl;
}


======================================
저장시간:2024-10-24 15:40:17.9529832
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 함수는 CODE 영역에 기록됨. main, show 
// ----------------------------------------------------------------

#include <iostream>    
#include <string>
#include <Windows.h>
#include <mmsystem.h>
#include "save.h"

#pragma comment(lib,"winmm.lib")

class Dog {			
private:		// default access-modifier
	std::string name;
	int age;

public:
	Dog() {
		std::cout << "디폴트 생성자" << std::endl;
		PlaySound(L"개소리.wav", NULL, SND_SYNC);
	}
	~Dog() {
		std::cout << "소멸자" << std::endl;
		PlaySound(L"개소멸.wav", NULL, SND_SYNC);
	}
};
             
Dog dog;

//--------
int main()
//--------
{
	std::cout << "메인 시작" << std::endl;

	save("메인.cpp");

	std::cout << "메인 끝나기 전" << std::endl;
}


======================================
저장시간:2024-10-24 15:49:34.3944092
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 1 단계 : instancing
// 2 단계 : initialization
// ~ : tilde
// ----------------------------------------------------------------

#include <iostream>    
#include <string>
#include <Windows.h>
#include <mmsystem.h>
#include "save.h"

#pragma comment(lib,"winmm.lib")

class Dog {			
private:		// default access-modifier
	std::string name;
	int age;

public:
	Dog() {
		std::cout << "디폴트 생성자" << std::endl;
		PlaySound(L"개소리.wav", NULL, SND_SYNC);
	}
	~Dog() {
		std::cout << "소멸자" << std::endl;
		PlaySound(L"개소멸.wav", NULL, SND_SYNC);
	}
};

//--------
int main()
//--------
{
	std::cout << "메인 시작" << std::endl;

	new Dog;

	save("메인.cpp");

	std::cout << "메인 끝나기 전" << std::endl;
}


======================================
저장시간:2024-10-24 15:52:11.5637180
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 1 단계 : instancing
// 2 단계 : initialization
// ~ : tilde
// ----------------------------------------------------------------

#include <iostream>    
#include <string>
#include <Windows.h>
#include <mmsystem.h>
#include "save.h"

#pragma comment(lib,"winmm.lib")

class Dog {			
private:		// default access-modifier
	std::string name;
	int age;

public:
	Dog() {
		std::cout << "디폴트 생성자" << std::endl;
		PlaySound(L"개소리.wav", NULL, SND_SYNC);
	}
	~Dog() {
		std::cout << "소멸자" << std::endl;
		PlaySound(L"개소멸.wav", NULL, SND_SYNC);
	}
};

//--------
int main()
//--------
{
	save("메인.cpp");

	Dog* p = new Dog;

	delete[] p;
}


======================================
저장시간:2024-10-24 15:53:16.2068382
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 1 단계 : instancing
// 2 단계 : initialization
// ~ : tilde
// ----------------------------------------------------------------

#include <iostream>    
#include <string>
#include <Windows.h>
#include <mmsystem.h>
#include "save.h"

#pragma comment(lib,"winmm.lib")

class Dog {			
private:		// default access-modifier
	std::string name;
	int age;

public:
	Dog() {
		std::cout << "디폴트 생성자" << std::endl;
		PlaySound(L"개소리.wav", NULL, SND_SYNC);
	}
	~Dog() {
		std::cout << "소멸자" << std::endl;
		PlaySound(L"개소멸.wav", NULL, SND_SYNC);
	}
};

//--------
int main()
//--------
{
	save("메인.cpp");

	Dog* p = new Dog;

	delete p;		// delete[] p; 의 경우 여러번 반환시키는 것이기에 []를 없애 한번만 반환시키면 프로그램이 죽지 않는다.
}


======================================
저장시간:2024-10-24 16:17:34.7963961
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>    
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");

	// [문제] 다음 코드가 문제없이 실행되도록 하자.
	// MemoryMonster는 생성시에 전달된 int 개수만큼 int를 저장할 메모리를 확보한다.
	// 그리고 메모리의 값을 1부터 시작하는 정수로 채워나간다.

	std::cout << "몇 개나 만들까?";
	int num;
	std::cin >> num;

	class MemoryMonster {
		int num;
		int* p;
	public:
		MemoryMonster(int num) : num{ num } {
			int* p = new int[num];
			for (int i{}; i < num; ++i)
				p[i] = i + 1;
		};
		
		void show() {
			for (int i{}; i < num; ++i)
				std::cout << i << " ";
			std::cout << std::endl;
		}
	};

	MemoryMonster a{ num };

	a.show();		// 1부터 num까지 숫자가 화면에 출력되어야 한다.
}


======================================
저장시간:2024-10-24 16:19:01.0308003
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>    
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");

	// [문제] 다음 코드가 문제없이 실행되도록 하자.
	// MemoryMonster는 생성시에 전달된 int 개수만큼 int를 저장할 메모리를 확보한다.
	// 그리고 메모리의 값을 1부터 시작하는 정수로 채워나간다.

	std::cout << "몇 개나 만들까?";
	int num;
	std::cin >> num;

	class MemoryMonster {
		int num;
		int* p;
	public:
		MemoryMonster(int num) : num{ num } {
			p = new int[num];
			for (int i{}; i < num; ++i)
				p[i] = i + 1;
		};
		
		void show() {
			for (int i{}; i < num; ++i)
				std::cout << p[i] << " ";
			std::cout << std::endl;
		}
	};

	MemoryMonster a{ num };

	a.show();		// 1부터 num까지 숫자가 화면에 출력되어야 한다.
}


======================================
저장시간:2024-10-24 16:28:19.9888462
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>    
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	MemoryMonster(int num) : num{ num } {
		p = new int[num];
		for (int i{}; i < num; ++i)
			p[i] = i + 1;
	};

	void show() {
		for (int i{}; i < num; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

//--------
int main()
//--------
{
	save("메인.cpp");

	// [문제] 다음 코드가 문제없이 실행되도록 하자.
	// MemoryMonster는 생성시에 전달된 int 개수만큼 int를 저장할 메모리를 확보한다.
	// 그리고 메모리의 값을 1부터 시작하는 정수로 채워나간다.

	std::cout << "몇 개나 만들까?";
	int num;
	std::cin >> num;

	MemoryMonster a{ num };

	a.show();		// 1부터 num까지 숫자가 화면에 출력되어야 한다.
}

// 실행 안돼서 복붙함

#include <iostream>    
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)
			p[i] = i + 1;
	};
	
	~MemoryMonster( );		// 스페셜 함수

	}		// 이거 지워야 돌아감

	void show() {		// 인터페이서 함수
		for (int i{}; i < num; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster( )
{
	delete[] p;
}

======================================
저장시간:2024-10-24 16:39:36.1725026
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>    
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)
			p[i] = i + 1;

	};
	
	~MemoryMonster( );		// 스페셜 함수

	void show() {		// 인터페이서 함수
		for (int i{}; i < num; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster( )
{
	delete[] p;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	// [문제] 실행 후 결과를 해석하라.		// 중간고사 비슷한 형식으로 문제 냈음

	MemoryMonster a{ 100 };

	MemoryMonster b = a;

}


======================================
저장시간:2024-10-24 16:51:45.3416527
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>    
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)
			p[i] = i + 1;

	};
	
	~MemoryMonster( );		// 스페셜 함수

	void show() {		// 인터페이서 함수
		for (int i{}; i < num; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster( )
{
	delete[] p;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	// [문제] 실행 후 결과를 해석하라.		

	// b와 a가 같은 메모리를 가리키고 있는 상황에서 b가 먼저 소멸될 때는 아무런 문제없이 소멸되지만 a가 사라질 때는 소멸될 메모리가 없기에 죽는다. 

	MemoryMonster a{ 100 };

	MemoryMonster b = a;		// b=a;의 의미 b{a}; 와 동일한 의미

}


======================================
저장시간:2024-10-24 16:55:10.6132615
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>    
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)
			p[i] = i + 1;
		std::cout << "생성자 호출됨" << std::endl;
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{other.num}, p{ other.p } {
		std::cout << "복사생성자" << std::endl;
	}
	
	~MemoryMonster( );		// 스페셜 함수

	void show() {		// 인터페이서 함수
		for (int i{}; i < num; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster( )
{
	delete[] p;
	std::cout << "소멸자 호출됨" << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	// [문제] 실행 후 결과를 해석하라.		

	// b와 a가 같은 메모리를 가리키고 있는 상황에서 b가 먼저 소멸될 때는 아무런 문제없이 소멸되지만 a가 사라질 때는 소멸될 메모리가 없기에 죽는다. 

	MemoryMonster a{ 100 };

	MemoryMonster b = a;		// b=a;의 의미 b{a}; 와 동일한 의미

}


======================================
저장시간:2024-10-24 16:56:13.5479792
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>    
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)
			p[i] = i + 1;
		std::cout << "생성자 호출됨" << this << std::endl;	
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{other.num}, p{ other.p } {
		std::cout << "복사생성자" << this << std::endl;
	}
	
	~MemoryMonster( );		// 스페셜 함수

	void show() {		// 인터페이서 함수
		for (int i{}; i < num; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster( )
{
	delete[] p;
	std::cout << "소멸자 호출됨 - " << this << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	// [문제] 실행 후 결과를 해석하라.		

	// b와 a가 같은 메모리를 가리키고 있는 상황에서 b가 먼저 소멸될 때는 아무런 문제없이 소멸되지만 a가 사라질 때는 소멸될 메모리가 없기에 죽는다. 

	MemoryMonster a{ 100 };

	MemoryMonster b = a;		// b=a;의 의미 b{a}; 와 동일한 의미

}


======================================
저장시간:2024-10-24 17:05:01.5282809
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 핵심키워드 - 깊은 복사 
// ----------------------------------------------------------------

#include <iostream>    
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)
			p[i] = i + 1;
		std::cout << "생성자 호출됨" << this << std::endl;	
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{other.num}, p{ other.p } {
		std::cout << "복사생성자" << this << std::endl;
	}
	
	~MemoryMonster( );		// 스페셜 함수

	void show() {		// 인터페이서 함수
		for (int i{}; i < num; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster( )
{
	delete[] p;
	std::cout << "소멸자 호출됨 - " << this << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	// [문제] 실행 후 결과를 해석하라.		

	// b와 a가 같은 메모리를 가리키고 있는 상황에서 b가 먼저 소멸될 때는 아무런 문제없이 소멸되지만 a가 사라질 때는 소멸될 메모리가 없기에 죽는다. 

	MemoryMonster a{ 100 };

	MemoryMonster b{ a };		// b=a;의 의미 b{a}; 와 동일한 의미

}


======================================
저장시간:2024-10-30 15:55:37.1178111
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 1.instancing
// 2.initialization
// ----------------------------------------------------------------

#include <iostream>    
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	// 전부 스페셜 함수
	// MemoryMonster() = default;
	// ~MemoryMonster() = default;
	// MemoryMonster(const MemoryMonster& other) = default;
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨" << this << std::endl;	
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{other.num} {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		for (int i{}; i < num; ++i)		
			p[i] = other.p[i];
		std::cout << "복사생성자" << this << std::endl;
	}
	
	~MemoryMonster( );		// 스페셜 함수

	void show() {		// 인터페이서 함수
		for (int i{}; i < num; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster( )
{
	delete[] p;
	std::cout << "소멸자 호출됨 - " << this << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	// [문제] 실행 후 결과를 해석하라.		

	// b와 a가 같은 메모리를 가리키고 있는 상황에서 b가 먼저 소멸될 때는 아무런 문제없이 소멸되지만 a가 사라질 때는 소멸될 메모리가 없기에 죽는다. 

	MemoryMonster a{ 100 };

	MemoryMonster b{ a };		

}


======================================
저장시간:2024-10-30 16:02:32.9767833
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 1.instancing
// 2.initialization
// ----------------------------------------------------------------

#include <iostream>    
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	// 전부 스페셜 함수
	// MemoryMonster() = default;
	// ~MemoryMonster() = default;
	// MemoryMonster(const MemoryMonster& other) = default;
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨" << this << std::endl;	
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{other.num} {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자" << this << std::endl;
	}
	
	~MemoryMonster( );		// 스페셜 함수

	void show() {		// 인터페이서 함수
		for (int i{}; i < num; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster( )
{
	delete[] p;
	std::cout << "소멸자 호출됨 - " << this << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	// [문제] 실행 후 결과를 해석하라.		

	// b와 a가 같은 메모리를 가리키고 있는 상황에서 b가 먼저 소멸될 때는 아무런 문제없이 소멸되지만 a가 사라질 때는 소멸될 메모리가 없기에 죽는다. 

	MemoryMonster a{ 100 };

	MemoryMonster b{ a };		

}


======================================
저장시간:2024-10-30 16:03:10.7607820
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 1.instancing
// 2.initialization
// ----------------------------------------------------------------

#include <iostream>    
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	// 전부 스페셜 함수
	// MemoryMonster() = default;
	// ~MemoryMonster() = default;
	// MemoryMonster(const MemoryMonster& other) = default;
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << std::endl;	
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{other.num} {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << std::endl;
	}
	
	~MemoryMonster( );		// 스페셜 함수

	void show() {		// 인터페이서 함수
		for (int i{}; i < num; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster( )
{
	delete[] p;
	std::cout << "소멸자 호출됨 - " << this << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	// [문제] 실행 후 결과를 해석하라.		

	// b와 a가 같은 메모리를 가리키고 있는 상황에서 b가 먼저 소멸될 때는 아무런 문제없이 소멸되지만 a가 사라질 때는 소멸될 메모리가 없기에 죽는다. 

	MemoryMonster a{ 100 };

	MemoryMonster b{ a };		

}


======================================
저장시간:2024-10-30 16:11:35.1644507
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 1.instancing
// 2.initialization
// ----------------------------------------------------------------

#include <iostream>    
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	// 전부 스페셜 함수
	// MemoryMonster() = default;
	// ~MemoryMonster() = default;
	// MemoryMonster(const MemoryMonster& other) = default;

	MemoryMonster() {
		std::cout << "디폴트 생성자 - " << this << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << std::endl;	
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{other.num} {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << std::endl;
	}
	
	~MemoryMonster( );		// 스페셜 함수

	void show() {		// 인터페이서 함수
		for (int i{}; i < num; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster( )
{
	delete[] p;
	std::cout << "소멸자 호출됨 - " << this << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	MemoryMonster a[3]{ 3, 5, 7 };		// a[3] 뒤에 {}가 아예 없을때, {}만 있을때, {}안에 값이 있을때가 전부 다르다. 
								// 생성시에 initialization을 마음대로 했기때문에
	a[0].show();
	a[1].show();
	a[2].show();
}


======================================
저장시간:2024-10-30 16:12:15.4955497
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 1.instancing
// 2.initialization
// ----------------------------------------------------------------

#include <iostream>    
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	// 전부 스페셜 함수
	// MemoryMonster() = default;
	// ~MemoryMonster() = default;
	// MemoryMonster(const MemoryMonster& other) = default;

	MemoryMonster() {
		std::cout << "디폴트 생성자 - " << this << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << std::endl;	
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{other.num} {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << std::endl;
	}
	
	~MemoryMonster( );		// 스페셜 함수

	void show() {		// 인터페이서 함수
		for (int i{}; i < num; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster( )
{
	delete[] p;
	std::cout << "소멸자 호출됨 - " << this << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	MemoryMonster a[3]{ };		// a[3] 뒤에 {}가 아예 없을때, {}만 있을때, {}안에 값이 있을때가 전부 다르다. 
								// 생성시에 initialization을 마음대로 했기때문에
	a[0].show();
	a[1].show();
	a[2].show();
}


======================================
저장시간:2024-10-30 16:13:02.9252569
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 1.instancing
// 2.initialization
// ----------------------------------------------------------------

#include <iostream>    
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	// 전부 스페셜 함수
	// MemoryMonster() = default;
	// ~MemoryMonster() = default;
	// MemoryMonster(const MemoryMonster& other) = default;

	MemoryMonster() {
		std::cout << "디폴트 생성자 - " << this << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << std::endl;	
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{other.num} {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << std::endl;
	}
	
	~MemoryMonster( );		// 스페셜 함수

	void show() {		// 인터페이서 함수
		for (int i{}; i < num; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster( )
{
	delete[] p;
	std::cout << "소멸자 호출됨 - " << this << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	MemoryMonster a[300]{ };		// a[3] 뒤에 {}가 아예 없을때, {}만 있을때, {}안에 값이 있을때가 전부 다르다. 
								// 생성시에 initialization을 마음대로 했기때문에
	a[0].show();
	a[1].show();
	a[2].show();
}


======================================
저장시간:2024-10-30 16:19:12.8953181
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 1.instancing
// 2.initialization
// ----------------------------------------------------------------

#include <iostream>    
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	// 전부 스페셜 함수
	// MemoryMonster() = default;
	// ~MemoryMonster() = default;
	// MemoryMonster(const MemoryMonster& other) = default;

	MemoryMonster() {
		std::cout << "디폴트 생성자 - " << this << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << std::endl;	
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{other.num} {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << std::endl;
	}
	
	~MemoryMonster( );		// 스페셜 함수

	void show() {		// 인터페이서 함수
		for (int i{}; i < num; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster( )
{
	delete[] p;
	std::cout << "소멸자 호출됨 - " << this << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	MemoryMonster a[3]{ 3,5,7 };

	// range - for loop를 사용하여 a의 show()를 호출하라.

	for (MemoryMonster m : a)
		m.show();
}


======================================
저장시간:2024-10-30 16:24:54.8079899
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 1.instancing
// 2.initialization
// ----------------------------------------------------------------

#include <iostream>    
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	// 전부 스페셜 함수
	// MemoryMonster() = default;
	// ~MemoryMonster() = default;
	// MemoryMonster(const MemoryMonster& other) = default;

	MemoryMonster() {
		std::cout << "디폴트 생성자 - " << this << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << std::endl;	
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{other.num} {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << std::endl;
	}
	
	~MemoryMonster( );		// 스페셜 함수

	void show() {		// 인터페이서 함수
		for (int i{}; i < num; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster( )
{
	delete[] p;
	std::cout << "소멸자 호출됨 - " << this << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	MemoryMonster a[3]{ 3,5,7 };

	// range - for loop를 사용하여 a의 show()를 호출하라.

	for (MemoryMonster& m : a)
		m.show();
}


======================================
저장시간:2024-10-30 16:30:10.0991570
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 1.instancing
// 2.initialization
// ----------------------------------------------------------------

#include <iostream>    
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	// 전부 스페셜 함수
	// MemoryMonster() = default;
	// ~MemoryMonster() = default;
	// MemoryMonster(const MemoryMonster& other) = default;

	MemoryMonster() {
		std::cout << "디폴트 생성자 - " << this << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << std::endl;	
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{other.num} {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << std::endl;
	}
	
	~MemoryMonster( );		// 스페셜 함수

	void show() const {		// const 붙혀줌 ... const를 붙혔기에 num을 바꿀 수는 없다. 
		for (int i{}; i < num; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster( )
{
	delete[] p;
	std::cout << "소멸자 호출됨 - " << this << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	MemoryMonster a[3]{ 3,5,7 };

	// range - for loop를 사용하여 a의 show()를 호출하라.

	for (const MemoryMonster& m : a)			// const의 의미 : 읽기만 하겠어 , &의 의미 : 복사하지 않겠어
		m.show();
}


======================================
저장시간:2024-10-30 16:32:04.8437432
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 1.instancing
// 2.initialization
// ----------------------------------------------------------------

#include <iostream>    
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	// 전부 스페셜 함수
	// MemoryMonster() = default;
	// ~MemoryMonster() = default;
	// MemoryMonster(const MemoryMonster& other) = default;

	MemoryMonster() {
		std::cout << "디폴트 생성자 - " << this << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << std::endl;	
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{other.num} {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << std::endl;
	}
	
	~MemoryMonster( );		// 스페셜 함수

	void show() const {		// const 붙혀줌 ... const를 붙혔기에 num을 바꿀 수는 없다.		// volatile은 몰라도 됨.
		for (int i{}; i < num; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster( )
{
	delete[] p;
	std::cout << "소멸자 호출됨 - " << this << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	MemoryMonster a{ 3 };
	MemoryMonster b{ 5 };
}


======================================
저장시간:2024-10-30 16:32:26.7354119
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 1.instancing
// 2.initialization
// ----------------------------------------------------------------

#include <iostream>    
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	// 전부 스페셜 함수
	// MemoryMonster() = default;
	// ~MemoryMonster() = default;
	// MemoryMonster(const MemoryMonster& other) = default;

	MemoryMonster() {
		std::cout << "디폴트 생성자 - " << this << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << std::endl;	
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{other.num} {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << std::endl;
	}
	
	~MemoryMonster( );		// 스페셜 함수

	void show() const {		// const 붙혀줌 ... const를 붙혔기에 num을 바꿀 수는 없다.		// volatile은 몰라도 됨.
		for (int i{}; i < num; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster( )
{
	delete[] p;
	std::cout << "소멸자 호출됨 - " << this << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	MemoryMonster a{ 3 };
	MemoryMonster b{ 5 };

	a.show();
	b.show();
}


======================================
저장시간:2024-10-30 16:33:53.2661092
======================================

// ----------------------------------------------------------------
// 2024. 2학기 10.24 목         수78목78        (8주 1일)
// ----------------------------------------------------------------
// 10.31(목) - 9주 1일 - 중간시험 확정
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 1.instancing
// 2.initialization
// ----------------------------------------------------------------

#include <iostream>    
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	// 전부 스페셜 함수
	// MemoryMonster() = default;
	// ~MemoryMonster() = default;
	// MemoryMonster(const MemoryMonster& other) = default;

	MemoryMonster() {
		std::cout << "디폴트 생성자 - " << this << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << std::endl;	
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{other.num} {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << std::endl;
	}
	
	~MemoryMonster( );		// 스페셜 함수

	void show() const {		// const 붙혀줌 ... const를 붙혔기에 num을 바꿀 수는 없다.		// volatile은 몰라도 됨.
		for (int i{}; i < num; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster( )
{
	delete[] p;
	std::cout << "소멸자 호출됨 - " << this << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	MemoryMonster a{ 3 };
	MemoryMonster b{ 5 };

	a = b;

	a.show();
	b.show();
}


// 중간 시험 답(1)

#include <iostream>
using namespace std;

int main()
{
	new A[B];

	// 자료형 A크기를 갖는 메모리 B개를 free-store에 반환한다.

	cout << sizeof(A) * B << endl;
}


// 중간 시험 답(2)

#include <iostream>
using namespace std;

int main()
{
	if (not cin) {		// 오류가 있다면 
		cin.clear();	// 오류를 클리어한다
		while (cin.get() != '\n')
			;
		cout << "잘못된 입력입니다." << endl;
		continue;
	}
}


// 중간 시험 답(3)

#include <iostream>
using namespace std;

int main()
{
	// 지역객체에서 부른 디폴트생성자는 멤버변수의 값을 건드리지 않는다.
	// ( STACK에서 부른 생성자 ) 라는 뜻.
}


// 중간 시험 답(4)

#include <iostream>
using namespace std;

int main()
{
	// 컴파일러가 자체적으로 최적화하기 때문이다.
}


// 중간 시험 답(5)

#include <iostream>
using namespace std;

void toupper(char& c)
{
	c = std::toupper(c);		// C++ 에서는 함수오버로딩이 가능하기때문에 toupper라는 새로운 함수를 만들어도 문제없이 돌아간다. 
								// 여기서 toupper 앞에 std::를 붙혀 메인스페이스의 함수를 부르면 완벽하다.
}

int main()
{
	
}


// 중간 시험 답(6)

#include <iostream>
using namespace std;

int main()
{
	// 1

	for (int i = 0; i < 4; ++i) {
		int num;
		int val;
		for (int i = 0; i < num; ++i)
			in >> val;
	}
	
	int num;
	in >> num;
	cout << "묶음의 개수 - " << num << endl;
	int* p = new int[num];
	for (int i = 0; i < num; ++i)
		in >> p[i];
	cout << "마지막 int 값 - " << p[num - 1] << endl;

	// 2

	double sum{};
	for (int i = 0; i < num; ++i)
		sum += p[i];
	println("평균 - {:.2f}", sum / num);

	// 3

	int zeroCnt{};
	for (int i = 0; i < num; ++i)
		if (p[i] & 10 == 0)
			++zeroCnt;
	cout << "끝자리 값이 0인 개수 - " << zeroCnt << endl;
}

======================================
저장시간:2024-11-06 17:10:20.7289596
======================================

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (9주 2일)
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 
// 
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	/*MemoryMonster() = default;
	~MemoryMonster() = default;

	MemoryMonster( const MemoryMonster& other) = default;
	MemoryMonster& operator=( const MemoryMonster& other) = default;

	MemoryMonster( MemoryMonster&& other ) = default;
	MemoryMonster& operator=( MemoryMonster&& other) = default; */

	// 객체가 태어날 때, 사라질 때, 복사될 때, 복사할당될 때, 이동될 때, 이동할당될 때

	MemoryMonster() {
		std::cout << "디폴트 생성자 - " << this << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << std::endl;
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{ other.num } {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << std::endl;
	}

	~MemoryMonster();		// 스페셜 함수

	void show() const {		/* cv-qualifier */
		for (int i{}; i < num; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster()
{
	delete[] p;
	std::cout << "소멸자 호출됨 - " << this << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	MemoryMonster a{ 3 };
	MemoryMonster b{ 5 };

	a = b;

	a.show();
	b.show();
}

======================================
저장시간:2024-11-06 17:20:09.9339612
======================================

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (9주 2일)
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 
// 
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	/*MemoryMonster() = default;
	~MemoryMonster() = default;

	MemoryMonster( const MemoryMonster& other) = default;
	MemoryMonster& operator=( const MemoryMonster& other) = default;

	MemoryMonster( MemoryMonster&& other ) = default;
	MemoryMonster& operator=( MemoryMonster&& other) = default; */

	// 객체가 태어날 때, 사라질 때, 복사될 때, 복사할당될 때, 이동될 때, 이동할당될 때

	MemoryMonster() {
		std::cout << "디폴트 생성자 - " << this << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << std::endl;
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{ other.num } {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << std::endl;
	}

	~MemoryMonster();		// 스페셜 함수

	// a = b 
	MemoryMonster& operator=(const MemoryMonster& other) {
		// if ( p != nullptr )
		delete[] p;

		num = other.num;
		p = new int[num];

		memcpy(p, other.p, sizeof(int) * num);

		std::cout << "copy assignment operator - " << this << std::endl;

		return *this;
	}



	void show() const {		/* cv-qualifier */
		for (int i{}; i < num; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster()
{
	delete[] p;
	std::cout << "소멸자 호출됨 - " << this << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	MemoryMonster a{ 3 };
	MemoryMonster b{ 5 };

	a = b;	// copy assignment operator가 개입하는 special한 순간

	a.show();
	b.show();
}

======================================
저장시간:2024-11-07 15:35:53.1471409
======================================

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (9주 2일)
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 
// 
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	/*MemoryMonster() = default;
	~MemoryMonster() = default;

	MemoryMonster( const MemoryMonster& other) = default;
	MemoryMonster& operator=( const MemoryMonster& other) = default;

	MemoryMonster( MemoryMonster&& other ) = default;
	MemoryMonster& operator=( MemoryMonster&& other) = default; */

	// 객체가 태어날 때, 사라질 때, 복사될 때, 복사할당될 때, 이동될 때, 이동할당될 때

	MemoryMonster() {
		std::cout << "디폴트 생성자 - " << this << " - " << num << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << " - " << num << std::endl;
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{ other.num } {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << " - " << num << std::endl;
	}

	~MemoryMonster();		// 스페셜 함수

	// a = b 복사할당연산자
	MemoryMonster& operator=(const MemoryMonster& other) {
		// if ( p != nullptr )
		delete[] p;

		num = other.num;
		p = new int[num];

		memcpy(p, other.p, sizeof(int) * num);

		std::cout << "복사할당연산자 - " << this << " - " << num << std::endl;

		return *this;
	}



	void show() const {		/* cv-qualifier */
		std::cout << "show" << num << " - ";
		for (int i{}; i < num; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster()
{
	delete[] p;
	std::cout << "소멸자 - " << this << " - " << num << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	MemoryMonster a{ 3 };
	MemoryMonster b{ 5 };

	a = b;	// copy assignment operator가 개입하는 special한 순간

	a.show();
	b.show();
}

======================================
저장시간:2024-11-07 15:39:42.6628125
======================================

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (9주 2일)
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 
// 
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	/*MemoryMonster() = default;
	~MemoryMonster() = default;

	MemoryMonster( const MemoryMonster& other) = default;
	MemoryMonster& operator=( const MemoryMonster& other) = default;

	MemoryMonster( MemoryMonster&& other ) = default;
	MemoryMonster& operator=( MemoryMonster&& other) = default; */

	// 객체가 태어날 때, 사라질 때, 복사될 때, 복사할당될 때, 이동될 때, 이동할당될 때

	MemoryMonster() {
		std::cout << "디폴트 생성자 - " << this << " - " << num << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << " - " << num << std::endl;
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{ other.num } {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << " - " << num << std::endl;
	}

	~MemoryMonster();		// 스페셜 함수

	// a = b 복사할당연산자
	MemoryMonster& operator=(const MemoryMonster& other) {
		// if ( p != nullptr )
		delete[] p;

		num = other.num;
		p = new int[num];

		memcpy(p, other.p, sizeof(int) * num);

		std::cout << "복사할당연산자 - " << this << " - " << num << std::endl;

		return *this;
	}



	void show() const {		/* cv-qualifier */
		std::cout << "show" << num << " - ";
		int 출력개수 = num;
		if (출력개수 > 10)
			출력개수 = 10;
		for (int i{}; i < 출력개수; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster()
{
	delete[] p;
	std::cout << "소멸자 - " << this << " - " << num << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	MemoryMonster a{ 3 };
	MemoryMonster b{ 5 };

	a = b;	// copy assignment operator가 개입하는 special한 순간

	a.show();
	b.show();
}

======================================
저장시간:2024-11-07 15:42:56.7225791
======================================

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (9주 2일)
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 
// 
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	/*MemoryMonster() = default;
	~MemoryMonster() = default;

	MemoryMonster( const MemoryMonster& other) = default;
	MemoryMonster& operator=( const MemoryMonster& other) = default;

	MemoryMonster( MemoryMonster&& other ) = default;
	MemoryMonster& operator=( MemoryMonster&& other) = default; */

	// 객체가 태어날 때, 사라질 때, 복사될 때, 복사할당될 때, 이동될 때, 이동할당될 때

	MemoryMonster() {
		std::cout << "디폴트 생성자 - " << this << " - " << num << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << " - " << num << std::endl;
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{ other.num } {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << " - " << num << std::endl;
	}

	~MemoryMonster();		// 스페셜 함수

	// a = b 복사할당연산자
	MemoryMonster& operator=(const MemoryMonster& other) {
		// if ( p != nullptr )
		delete[] p;

		num = other.num;
		p = new int[num];

		memcpy(p, other.p, sizeof(int) * num);

		std::cout << "복사할당연산자 - " << this << " - " << num << std::endl;

		return *this;
	}



	void show() const {		/* cv-qualifier */
		std::cout << "show" << num << " - ";
		int 출력개수 = num;
		if (출력개수 > 10)
			출력개수 = 10;
		for (int i{}; i < 출력개수; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster()
{
	delete[] p;
	std::cout << "소멸자 - " << this << " - " << num << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	MemoryMonster mons[3]{ 10,30,20 };

	for (MemoryMonster mon : mons)
		mon.show();
}

======================================
저장시간:2024-11-07 15:56:39.2527865
======================================

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (9주 2일)
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 
// 
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	/*MemoryMonster() = default;
	~MemoryMonster() = default;

	MemoryMonster( const MemoryMonster& other) = default;
	MemoryMonster& operator=( const MemoryMonster& other) = default;

	MemoryMonster( MemoryMonster&& other ) = default;
	MemoryMonster& operator=( MemoryMonster&& other) = default; */

	// 객체가 태어날 때, 사라질 때, 복사될 때, 복사할당될 때, 이동될 때, 이동할당될 때

	MemoryMonster() {
		std::cout << "디폴트 생성자 - " << this << " - " << num << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << " - " << num << std::endl;
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{ other.num } {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << " - " << num << std::endl;
	}

	~MemoryMonster();		// 스페셜 함수

	// a = b 복사할당연산자
	MemoryMonster& operator=(const MemoryMonster& other) {
		// if ( p != nullptr )
		delete[] p;

		num = other.num;
		p = new int[num];

		memcpy(p, other.p, sizeof(int) * num);

		std::cout << "복사할당연산자 - " << this << " - " << num << std::endl;

		return *this;
	}



	void show() const {		/* cv-qualifier */
		std::cout << "show" << num << " - ";
		int 출력개수 = num;
		if (출력개수 > 10)
			출력개수 = 10;
		for (int i{}; i < 출력개수; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster()
{
	delete[] p;
	std::cout << "소멸자 - " << this << " - " << num << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	MemoryMonster mons[3]{ 10,30,20 };

	for (MemoryMonster& mon : mons)
		mon.show();
}

======================================
저장시간:2024-11-07 16:03:13.1606534
======================================

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (9주 2일)
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 
// 
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	/*MemoryMonster() = default;
	~MemoryMonster() = default;

	MemoryMonster( const MemoryMonster& other) = default;
	MemoryMonster& operator=( const MemoryMonster& other) = default;

	MemoryMonster( MemoryMonster&& other ) = default;
	MemoryMonster& operator=( MemoryMonster&& other) = default; */

	// 객체가 태어날 때, 사라질 때, 복사될 때, 복사할당될 때, 이동될 때, 이동할당될 때

	MemoryMonster() {
		std::cout << "디폴트 생성자 - " << this << " - " << num << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << " - " << num << std::endl;
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{ other.num } {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << " - " << num << std::endl;
	}

	~MemoryMonster();		// 스페셜 함수

	// a = b 복사할당연산자
	MemoryMonster& operator=(const MemoryMonster& other) {
		// if ( p != nullptr )
		delete[] p;

		num = other.num;
		p = new int[num];

		memcpy(p, other.p, sizeof(int) * num);

		std::cout << "복사할당연산자 - " << this << " - " << num << std::endl;

		return *this;
	}



	void show() const {		/* cv-qualifier */
		std::cout << "show" << num << " - ";
		int 출력개수 = num;
		if (출력개수 > 10)
			출력개수 = 10;
		for (int i{}; i < 출력개수; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster()
{
	delete[] p;
	std::cout << "소멸자 - " << this << " - " << num << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	MemoryMonster mons[3]{ 10,30,20 };

	// & - 객체를 복사하지 않겠다. 나는 너를 원격으로 READ/WRITE 하겠어.
	// const - 너의 메모리를 읽기만 하겠어.
	// const correctness(일관성)
	for (const MemoryMonster& mon : mons)	
		mon.show();
}

======================================
저장시간:2024-11-07 16:06:07.9408553
======================================

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (9주 2일)
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 
// 
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	/*MemoryMonster() = default;
	~MemoryMonster() = default;

	MemoryMonster( const MemoryMonster& other) = default;
	MemoryMonster& operator=( const MemoryMonster& other) = default;

	MemoryMonster( MemoryMonster&& other ) = default;
	MemoryMonster& operator=( MemoryMonster&& other) = default; */

	// 객체가 태어날 때, 사라질 때, 복사될 때, 복사할당될 때, 이동될 때, 이동할당될 때

	MemoryMonster() {
		std::cout << "디폴트 생성자 - " << this << " - " << num << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << " - " << num << std::endl;
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{ other.num } {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << " - " << num << std::endl;
	}

	~MemoryMonster();		// 스페셜 함수

	// a = b 복사할당연산자
	MemoryMonster& operator=(const MemoryMonster& other) {
		// if ( p != nullptr )
		delete[] p;

		num = other.num;
		p = new int[num];

		memcpy(p, other.p, sizeof(int) * num);

		std::cout << "복사할당연산자 - " << this << " - " << num << std::endl;

		return *this;
	}


	// 함수의 자격을 인정하는 cv-q	qualifier
	void show() const {	
		std::cout << "show" << num << " - ";
		int 출력개수 = num;
		if (출력개수 > 10)
			출력개수 = 10;
		for (int i{}; i < 출력개수; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster()
{
	delete[] p;
	std::cout << "소멸자 - " << this << " - " << num << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	MemoryMonster mons[3]{ 10,30,20 };

	// & - 객체를 복사하지 않겠다. 나는 너를 원격으로 READ/WRITE 하겠어.
	// const - 너의 메모리를 읽기만 하겠어.
	// const correctness(일관성)
	for (const MemoryMonster& mon : mons)	
		mon.show();		// void show() 뒤의 const를 지우면 충돌이 발생한다. 
						// 이유 - for문에서는 읽기만 하겠다 했는데 void show에서는 const가 없어 값을 바꿔버릴 수 있기 때문이다.
}

======================================
저장시간:2024-11-07 16:08:48.8943958
======================================

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (9주 2일)
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 
// 
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	/*MemoryMonster() = default;
	~MemoryMonster() = default;

	MemoryMonster( const MemoryMonster& other) = default;
	MemoryMonster& operator=( const MemoryMonster& other) = default;

	MemoryMonster( MemoryMonster&& other ) = default;
	MemoryMonster& operator=( MemoryMonster&& other) = default; */

	// 객체가 태어날 때, 사라질 때, 복사될 때, 복사할당될 때, 이동될 때, 이동할당될 때

	MemoryMonster() {
		std::cout << "디폴트 생성자 - " << this << " - " << num << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << " - " << num << std::endl;
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{ other.num } {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << " - " << num << std::endl;
	}

	~MemoryMonster();		// 스페셜 함수

	// a = b 복사할당연산자
	MemoryMonster& operator=(const MemoryMonster& other) {
		// if ( p != nullptr )
		delete[] p;

		num = other.num;
		p = new int[num];

		memcpy(p, other.p, sizeof(int) * num);

		std::cout << "복사할당연산자 - " << this << " - " << num << std::endl;

		return *this;
	}


	// 함수의 자격을 인정하는 cv-q	qualifier
	void show() const {	
		std::cout << "show" << num << " - ";
		int 출력개수 = num;
		if (출력개수 > 10)
			출력개수 = 10;
		for (int i{}; i < 출력개수; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster()
{
	delete[] p;
	std::cout << "소멸자 - " << this << " - " << num << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	MemoryMonster a{ 10 };

	a = a = a;
}

======================================
저장시간:2024-11-07 16:12:34.7571715
======================================

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (9주 2일)
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 
// 
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	/*MemoryMonster() = default;
	~MemoryMonster() = default;

	MemoryMonster( const MemoryMonster& other) = default;
	MemoryMonster& operator=( const MemoryMonster& other) = default;

	MemoryMonster( MemoryMonster&& other ) = default;
	MemoryMonster& operator=( MemoryMonster&& other) = default; */

	// 객체가 태어날 때, 사라질 때, 복사될 때, 복사할당될 때, 이동될 때, 이동할당될 때

	MemoryMonster() {
		std::cout << "디폴트 생성자 - " << this << " - " << num << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << " - " << num << std::endl;
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{ other.num } {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << " - " << num << std::endl;
	}

	~MemoryMonster();		// 스페셜 함수

	// a = b 복사할당연산자
	MemoryMonster& operator=(const MemoryMonster& other) {
		// 나를 나로 할당하는 동작을 막아야 겠다.
		if (this == &other)
			return *this;

		// if ( p != nullptr )
		delete[] p;

		num = other.num;
		p = new int[num];

		memcpy(p, other.p, sizeof(int) * num);

		std::cout << "복사할당연산자 - " << this << " - " << num << std::endl;

		return *this;
	}


	// 함수의 자격을 인정하는 cv-q	qualifier
	void show() const {	
		std::cout << "show" << num << " - ";
		int 출력개수 = num;
		if (출력개수 > 10)
			출력개수 = 10;
		for (int i{}; i < 출력개수; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster()
{
	delete[] p;
	std::cout << "소멸자 - " << this << " - " << num << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	MemoryMonster a{ 10 };

	a = a = a;
}

======================================
저장시간:2024-11-07 16:13:11.2468405
======================================

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (9주 2일)
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 
// 
// ----------------------------------------------------------------

#include <iostream>
#include "save.h"

class MemoryMonster {
	int num;
	int* p;
public:
	/*MemoryMonster() = default;
	~MemoryMonster() = default;

	MemoryMonster( const MemoryMonster& other) = default;
	MemoryMonster& operator=( const MemoryMonster& other) = default;

	MemoryMonster( MemoryMonster&& other ) = default;
	MemoryMonster& operator=( MemoryMonster&& other) = default; */

	// 객체가 태어날 때, 사라질 때, 복사될 때, 복사할당될 때, 이동될 때, 이동할당될 때

	MemoryMonster() {
		std::cout << "디폴트 생성자 - " << this << " - " << num << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << " - " << num << std::endl;
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{ other.num } {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << " - " << num << std::endl;
	}

	~MemoryMonster();		// 스페셜 함수

	// a = b 복사할당연산자
	MemoryMonster& operator=(const MemoryMonster& other) {
		// 나를 나로 할당하는 동작을 막아야 겠다.
		if (this == &other)
			return *this;

		// if ( p != nullptr )
		delete[] p;

		num = other.num;
		p = new int[num];

		memcpy(p, other.p, sizeof(int) * num);

		std::cout << "복사할당연산자 - " << this << " - " << num << std::endl;

		return *this;
	}


	// 함수의 자격을 인정하는 cv-q	qualifier
	void show() const {	
		std::cout << "show" << num << " - ";
		int 출력개수 = num;
		if (출력개수 > 10)
			출력개수 = 10;
		for (int i{}; i < 출력개수; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster()
{
	delete[] p;
	std::cout << "소멸자 - " << this << " - " << num << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	MemoryMonster a{ 10 };

	a = a = a;
}


======================================
저장시간:2024-11-07 16:19:31.6036585
======================================

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (9주 2일)
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 
// 
// ----------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"

std::default_random_engine dre;
std::uniform_int_distribution uid;

class MemoryMonster {
	int num;
	int* p;
public:
	/*MemoryMonster() = default;
	~MemoryMonster() = default;

	MemoryMonster( const MemoryMonster& other) = default;
	MemoryMonster& operator=( const MemoryMonster& other) = default;

	MemoryMonster( MemoryMonster&& other ) = default;
	MemoryMonster& operator=( MemoryMonster&& other) = default; */

	// 객체가 태어날 때, 사라질 때, 복사될 때, 복사할당될 때, 이동될 때, 이동할당될 때

	MemoryMonster() : num{ uid(dre) } {
		p = new int{num} ;
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
		std::cout << "디폴트 생성자 - " << this << " - " << num << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << " - " << num << std::endl;
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{ other.num } {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << " - " << num << std::endl;
	}

	~MemoryMonster();		// 스페셜 함수

	// a = b 복사할당연산자
	MemoryMonster& operator=(const MemoryMonster& other) {
		// 나를 나로 할당하는 동작을 막아야 겠다.
		if (this == &other)
			return *this;

		// if ( p != nullptr )
		delete[] p;

		num = other.num;
		p = new int[num];

		memcpy(p, other.p, sizeof(int) * num);

		std::cout << "복사할당연산자 - " << this << " - " << num << std::endl;

		return *this;
	}


	// 함수의 자격을 인정하는 cv-q	qualifier
	void show() const {	
		std::cout << "show" << num << " - ";
		int 출력개수 = num;
		if (출력개수 > 10)
			출력개수 = 10;
		for (int i{}; i < 출력개수; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster()
{
	delete[] p;
	std::cout << "소멸자 - " << this << " - " << num << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	// [문제] 다음 MemoryMonster를 num 기준 오름차순으로 정렬하라.

	MemoryMonster mons[30];

	// 오름차순정렬

	for (const MemoryMonster& mon : mons)
		mon.show();
}

======================================
저장시간:2024-11-07 16:20:45.8429235
======================================

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (9주 2일)
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 
// 
// ----------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"

std::default_random_engine dre;
std::uniform_int_distribution uid{1,99};

class MemoryMonster {
	int num;
	int* p;
public:
	/*MemoryMonster() = default;
	~MemoryMonster() = default;

	MemoryMonster( const MemoryMonster& other) = default;
	MemoryMonster& operator=( const MemoryMonster& other) = default;

	MemoryMonster( MemoryMonster&& other ) = default;
	MemoryMonster& operator=( MemoryMonster&& other) = default; */

	// 객체가 태어날 때, 사라질 때, 복사될 때, 복사할당될 때, 이동될 때, 이동할당될 때

	MemoryMonster() : num{ uid(dre) } {
		p = new int{num} ;
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
		std::cout << "디폴트 생성자 - " << this << " - " << num << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << " - " << num << std::endl;
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{ other.num } {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << " - " << num << std::endl;
	}

	~MemoryMonster();		// 스페셜 함수

	// a = b 복사할당연산자
	MemoryMonster& operator=(const MemoryMonster& other) {
		// 나를 나로 할당하는 동작을 막아야 겠다.
		if (this == &other)
			return *this;

		// if ( p != nullptr )
		delete[] p;

		num = other.num;
		p = new int[num];

		memcpy(p, other.p, sizeof(int) * num);

		std::cout << "복사할당연산자 - " << this << " - " << num << std::endl;

		return *this;
	}


	// 함수의 자격을 인정하는 cv-q	qualifier
	void show() const {	
		std::cout << "show" << num << " - ";
		int 출력개수 = num;
		if (출력개수 > 10)
			출력개수 = 10;
		for (int i{}; i < 출력개수; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster()
{
	delete[] p;
	std::cout << "소멸자 - " << this << " - " << num << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	// [문제] 다음 MemoryMonster를 num 기준 오름차순으로 정렬하라.

	MemoryMonster mons[30];

	// 오름차순정렬

	for (const MemoryMonster& mon : mons)
		mon.show();
}


// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (9주 2일)
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 버퍼 오버런때문에 프로그램 종료됨. 이유 모름.
// ----------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"

std::default_random_engine dre;
std::uniform_int_distribution uid{ 1,99 };

class MemoryMonster {
private:
	int num;
	int* p;
public:
	/*MemoryMonster() = default;
	~MemoryMonster() = default;

	MemoryMonster( const MemoryMonster& other) = default;
	MemoryMonster& operator=( const MemoryMonster& other) = default;

	MemoryMonster( MemoryMonster&& other ) = default;
	MemoryMonster& operator=( MemoryMonster&& other) = default; */

	// 객체가 태어날 때, 사라질 때, 복사될 때, 복사할당될 때, 이동될 때, 이동할당될 때

	MemoryMonster() : num{ uid(dre) } {
		p = new int{num} ;
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
		std::cout << "디폴트 생성자 - " << this << " - " << num << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << " - " << num << std::endl;
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{ other.num } {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << " - " << num << std::endl;
	}

	~MemoryMonster();		// 스페셜 함수

	// a = b 복사할당연산자
	MemoryMonster& operator=(const MemoryMonster& other) {
		// 나를 나로 할당하는 동작을 막아야 겠다.
		if (this == &other)
			return *this;

		// if ( p != nullptr )
		delete[] p;

		num = other.num;
		p = new int[num];

		memcpy(p, other.p, sizeof(int) * num);

		std::cout << "복사할당연산자 - " << this << " - " << num << std::endl;

		return *this;
	}

	// 바깥 세상과 소통하기 위한 interface 함수
	int getNum() const {
		return num;
	}

	// 함수의 자격을 인정하는 cv-q	qualifier
	void show() const {	
		std::cout << "show" << num << " - ";
		int 출력개수 = num;
		if (출력개수 > 10)
			출력개수 = 10;
		for (int i{}; i < 출력개수; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster()
{
	delete[] p;
	std::cout << "소멸자 - " << this << " - " << num << std::endl;
}

//--------
int main()
//--------
{
	//save("메인.cpp");

	// [문제] 다음 MemoryMonster를 num 기준 오름차순으로 정렬하라.

	MemoryMonster mons[30];

	// 오름차순정렬
	qsort(mons, sizeof(mons) / sizeof(MemoryMonster), sizeof(MemoryMonster), [](const void* a, const void* b) {
		MemoryMonster m1 = *(MemoryMonster*)a;
		MemoryMonster m2 = *(MemoryMonster*)b;

		return m1.getNum() - m2.getNum();
		});


	std::cout << std::endl << "정렬 후" << std::endl;
	for (const MemoryMonster& mon : mons)
		mon.show();
	std::cout << std::endl;
}


// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (9주 2일)
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------
// special member - 디폴트 생성자/소멸자, 복사생성자/복사할당연산자, 
//	( 총 6가지 )		이동생성자/이동할당연산자
// ----------------------------------------------------------------
// 이것도 오류때문에 실행 안됨. 
// ----------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"

std::default_random_engine dre;
std::uniform_int_distribution uid{ 1,99 };

class MemoryMonster {
private:
	int num;
	int* p;
public:
	/*MemoryMonster() = default;
	~MemoryMonster() = default;

	MemoryMonster( const MemoryMonster& other) = default;
	MemoryMonster& operator=( const MemoryMonster& other) = default;

	MemoryMonster( MemoryMonster&& other ) = default;
	MemoryMonster& operator=( MemoryMonster&& other) = default; */

	// 객체가 태어날 때, 사라질 때, 복사될 때, 복사할당될 때, 이동될 때, 이동할당될 때

	MemoryMonster() : num{ uid(dre) } {
		p = new int{num} ;
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
		std::cout << "디폴트 생성자 - " << this << " - " << num << std::endl;
	}
	MemoryMonster(int num) : num{ num } {		// 이것은 스페셜 함수가 아님을 꼭 주의해라. 생성자 이긴함
		p = new int[num];
		for (int i{}; i < num; ++i)		// 생성시 1부터 100까지 채워라.
			p[i] = i + 1;
		std::cout << "생성자 호출됨 - " << this << " - " << num << std::endl;
	};

	// 복사생성자 - copy constructor
	// 이거 코딩안하면 컴파일러가 이 함수를 자동으로 생성한다. - 그래서 스페셜 함수이다.
	MemoryMonster(const MemoryMonster& other) : num{ other.num } {
		p = new int[num];

		// 깊은 복사를 이렇게 하면 바보된다.
		// for (int i{}; i < num; ++i)	
		// 	
			// p[i] = other.p[i];

		// 실제 코드
		memcpy(p, other.p, sizeof(int) * num);		// DMA 
		std::cout << "복사생성자 - " << this << " - " << num << std::endl;
	}

	~MemoryMonster();		// 스페셜 함수

	// a = b 복사할당연산자
	MemoryMonster& operator=(const MemoryMonster& other) {
		// 나를 나로 할당하는 동작을 막아야 겠다.
		if (this == &other)
			return *this;

		// if ( p != nullptr )
		delete[] p;

		num = other.num;
		p = new int[num];

		memcpy(p, other.p, sizeof(int) * num);

		std::cout << "복사할당연산자 - " << this << " - " << num << std::endl;

		return *this;
	}

	// 바깥 세상과 소통하기 위한 interface 함수
	int getNum() const {
		return num;
	}

	// 함수의 자격을 인정하는 cv-q	qualifier
	void show() const {	
		std::cout << "show" << num << " - ";
		int 출력개수 = num;
		if (출력개수 > 10)
			출력개수 = 10;
		for (int i{}; i < 출력개수; ++i)
			std::cout << p[i] << " ";
		std::cout << std::endl;
	}
};

MemoryMonster::~MemoryMonster()
{
	delete[] p;
	std::cout << "소멸자 - " << this << " - " << num << std::endl;
}

//--------
int main()
//--------
{
	save("메인.cpp");

	// [문제] 다음 MemoryMonster를 num 기준 오름차순으로 정렬하라.

	MemoryMonster mons[30];

	// 오름차순정렬
	qsort(mons, sizeof(mons) / sizeof(MemoryMonster), sizeof(MemoryMonster), [](const void* a, const void* b) {
		MemoryMonster m1& = *(MemoryMonster*)a;
		MemoryMonster m2& = *(MemoryMonster*)b;

		return m1.getNum() - m2.getNum();
		});


	std::cout << std::endl << "정렬 후" << std::endl;
	for (const MemoryMonster& mon : mons)
		mon.show();
	std::cout << std::endl;
}


======================================
저장시간:2024-11-07 17:11:31.9475215
======================================

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (9주 2일)
// ----------------------------------------------------------------
// 연산자 오버로딩( operator overloading )
// std::string을 흉내낸 STRING을 작성
// int를 흉내낸 INT를 작성하여 연산자를 오버로딩할 필요성
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");

	std::string s{ "The C++ Program Language." };	// char [], char*을 대체하기 위해 사용
	std::cout << "s의 글자 수 - " << s.size() << std::endl;

	for (char c : s)
		std::cout << c << "-";
	std::cout << std::endl;

	s = s + "정말 재미있는 언어네요. 배우고 싶어서 잠이 안와요";
	std::cout << s << std::endl;
}


// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (9주 2일)
// ----------------------------------------------------------------
// 연산자 오버로딩( operator overloading )
// std::string을 흉내낸 STRING을 작성
// int를 흉내낸 INT를 작성하여 연산자를 오버로딩할 필요성
// ----------------------------------------------------------------
// 
// ----------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

//--------
int main()
//--------
{
	save("메인.cpp");

	// [문제] 이 코드가 문제없이 실행되도록 class string을 코딩하라.
	// 적어도 아래 2줄은 여러분 모두 코딩할 수 있습니다.
	// 다음 주 올때까지 살려주세요. 제발요~~~~~~~~

	class STRING {
	public:
		STRING(const char* str) {
			// 집에서 해보고 오기
		}
	};

	STRING s{ "The C++ Program Language." };	// char [], char*을 대체하기 위해 사용
	std::cout << "s의 글자 수 - " << s.size() << std::endl;

	for (int i = 0; i < s.size(); ++i)
		std::cout << s[i] << "-";
	for (char c : s)
		std::cout << c << "-";
	std::cout << std::endl;

	s = s + "정말 재미있는 언어네요. 배우고 싶어서 잠이 안와요";
	std::cout << s << std::endl;
}

======================================
저장시간:2024-11-13 15:03:54.8583170
======================================

#include<iostream>
#include<string>
#include"save.h"

class STRING {

public:

	STRING(const char* str) {
		while (str[size_str] != '\0') {
			++size_str;
		}
		p = new char[size_str + 1];
		p[size_str] = '\0';
		memcpy(p, str, strlen(str));

		/*for (int i{}; i < size_str; ++i) {
		p[i] = str[i];
		}*/

	}

	int size() {
		return size_str;
	}

	void Ssize_str() {
		std::cout << size_str << std::endl;
	}

	char operator[](int index) const {
		if (index >= 0 && index < size_str) {
			return p[index];
		}
		return '\0';
	}

	~STRING() {
		delete[] p;
	}


private:

	//int size_str{};
	size_t size_str{};
	char* p;

};

int main()
{
	save("메인.cpp");

	// 이게 전부 돌아가도록 만들기

	STRING s{ "The C++ Programming Language." };
	std::cout << "s의 글자 수 : " << s.size() << std::endl;

	//std::string s;  
	for (int i = 0; i < s.size(); ++i) {
		std::cout << s[i] << "-";
	}

	std::cout << std::endl;
}






======================================
저장시간:2024-11-13 15:48:52.6978786
======================================

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (10주 2일)
// ----------------------------------------------------------------
// 연산자 오버로딩( operator overloading )
// std::string을 흉내낸 STRING을 작성
// int를 흉내낸 INT를 작성하여 연산자를 오버로딩할 필요성
// ----------------------------------------------------------------
// "  " : 아주 낡고 오래된 약속.	=> hello '\0'
// string 안에는 두 가지 요소가 있음
// 1.글자수	2. 글자*
// ----------------------------------------------------------------

#include<iostream>
#include<string>
#include"save.h"

class STRING {
public:
	STRING(const char* s) : num{ strlen(s) } {
		p = new char[num];
		memcpy(p, s, num);
		
	}

	size_t size() const {
		return num;
	}

	~STRING() {
		delete[] p;
	}
private:
	size_t num{};
	char* p;
};

int main()
{
	save("메인.cpp");

	// 이게 전부 돌아가도록 만들기

	STRING s{ "The C++ Programming Language." };
	std::cout << "s의 글자 수 : " << s.size() << std::endl;

	/*s = s + "정말 재미있는 언어네요. 배우고 싶어서 잠이 안와요";
	std::cout << s << std::endl;*/
}


======================================
저장시간:2024-11-13 15:51:22.3755442
======================================

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (10주 2일)
// ----------------------------------------------------------------
// 연산자 오버로딩( operator overloading )
// std::string을 흉내낸 STRING을 작성
// int를 흉내낸 INT를 작성하여 연산자를 오버로딩할 필요성
// ----------------------------------------------------------------
// "  " : 아주 낡고 오래된 약속.	=> hello '\0'
// string 안에는 두 가지 요소가 있음
// 1.글자수	2. 글자*
// ----------------------------------------------------------------

#include<iostream>
#include<string>
#include"save.h"

class STRING {
public:
	STRING() = default;	// 디폴트 생성자를 반드시 만들어줘야 한다.
	STRING(const char* s) : num{ strlen(s) } {	//RAII
		p = new char[num];
		memcpy(p, s, num);
		
	}

	// 복사생성자와 복사할당연산자까지 코딩해야 한다.
	size_t size() const {
		return num;
	}

	~STRING() {
		delete[] p;
	}
private:
	size_t num{};
	char* p{};
};

int main()
{
	save("메인.cpp");

	// 이게 전부 돌아가도록 만들기

	STRING s{ "The C++ Programming Language." };
	std::cout << "s의 글자 수 : " << s.size() << std::endl;

	/*s = s + "정말 재미있는 언어네요. 배우고 싶어서 잠이 안와요";
	std::cout << s << std::endl;*/
}


======================================
저장시간:2024-11-13 16:17:46.3542722
======================================

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (10주 2일)
// ----------------------------------------------------------------
// 연산자 오버로딩( operator overloading )
// std::string을 흉내낸 STRING을 작성
// int를 흉내낸 INT를 작성하여 연산자를 오버로딩할 필요성
// ----------------------------------------------------------------
// "  " : 아주 낡고 오래된 약속.	=> hello '\0'
// string 안에는 두 가지 요소가 있음
// 1.글자수	2. 글자*
// ----------------------------------------------------------------

#include<iostream>
#include"save.h"
#include"STRING.h"



int main()
{
	save("메인.cpp");

	// 이게 전부 돌아가도록 만들기

	STRING s{ "The C++ Programming Language." };
	std::cout << "s의 글자 수 : " << s.size() << std::endl;

	/*s = s + "정말 재미있는 언어네요. 배우고 싶어서 잠이 안와요";
	std::cout << s << std::endl;*/
}


======================================
저장시간:2024-11-13 16:18:53.1439877
======================================

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (10주 2일)
// ----------------------------------------------------------------
// 연산자 오버로딩( operator overloading )
// std::string을 흉내낸 STRING을 작성
// int를 흉내낸 INT를 작성하여 연산자를 오버로딩할 필요성
// ----------------------------------------------------------------
// "  " : 아주 낡고 오래된 약속.	=> hello '\0'
// string 안에는 두 가지 요소가 있음
// 1.글자수	2. 글자*
// ----------------------------------------------------------------

#include<iostream>
#include"save.h"
#include"STRING.h"

extern bool 관찰;

//--------
int main()
//--------
{
	save("메인.cpp");

	// 이게 전부 돌아가도록 만들기

	관찰 = true;
	STRING s{ "The C++ Programming Language." };
	관찰 = false;
	std::cout << "s의 글자 수 : " << s.size() << std::endl;

	/*s = s + "정말 재미있는 언어네요. 배우고 싶어서 잠이 안와요";
	std::cout << s << std::endl;*/
}


======================================
저장시간:2024-11-13 16:32:32.6134507
======================================

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (10주 2일)
// ----------------------------------------------------------------
// 연산자 오버로딩( operator overloading )
// std::string을 흉내낸 STRING을 작성
// int를 흉내낸 INT를 작성하여 연산자를 오버로딩할 필요성
// ----------------------------------------------------------------
// "  " : 아주 낡고 오래된 약속.	=> hello '\0'
// string 안에는 두 가지 요소가 있음
// 1.글자수	2. 글자*
// ----------------------------------------------------------------

#include<iostream>
#include"save.h"
#include"STRING.h"

extern bool 관찰;

//--------
int main()
//--------
{
	save("메인.cpp");

	STRING s[5]{ "1","333","55555","22","4444", };

	for (STRING s : s)
		std::cout << s.size() << std::endl;
}


======================================
저장시간:2024-11-13 16:33:06.1009991
======================================

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (10주 2일)
// ----------------------------------------------------------------
// 연산자 오버로딩( operator overloading )
// std::string을 흉내낸 STRING을 작성
// int를 흉내낸 INT를 작성하여 연산자를 오버로딩할 필요성
// ----------------------------------------------------------------
// "  " : 아주 낡고 오래된 약속.	=> hello '\0'
// string 안에는 두 가지 요소가 있음
// 1.글자수	2. 글자*
// ----------------------------------------------------------------

#include<iostream>
#include"save.h"
#include"STRING.h"

extern bool 관찰;

//--------
int main()
//--------
{
	save("메인.cpp");

	관찰 = true;
	STRING s[5]{ "1","333","55555","22","4444", };

	for (STRING s : s)
		std::cout << s.size() << std::endl;
}


======================================
저장시간:2024-11-13 16:33:43.9835895
======================================

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (10주 2일)
// ----------------------------------------------------------------
// 연산자 오버로딩( operator overloading )
// std::string을 흉내낸 STRING을 작성
// int를 흉내낸 INT를 작성하여 연산자를 오버로딩할 필요성
// ----------------------------------------------------------------
// "  " : 아주 낡고 오래된 약속.	=> hello '\0'
// string 안에는 두 가지 요소가 있음
// 1.글자수	2. 글자*
// ----------------------------------------------------------------

#include<iostream>
#include"save.h"
#include"STRING.h"

extern bool 관찰;

//--------
int main()
//--------
{
	save("메인.cpp");

	
	STRING s[5]{ "1","333","55555","22","4444", };

	관찰 = true;
	for (STRING s : s)
		std::cout << s.size() << std::endl;
	관찰 = false;
}


======================================
저장시간:2024-11-13 16:34:12.2455018
======================================

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (10주 2일)
// ----------------------------------------------------------------
// 연산자 오버로딩( operator overloading )
// std::string을 흉내낸 STRING을 작성
// int를 흉내낸 INT를 작성하여 연산자를 오버로딩할 필요성
// ----------------------------------------------------------------
// "  " : 아주 낡고 오래된 약속.	=> hello '\0'
// string 안에는 두 가지 요소가 있음
// 1.글자수	2. 글자*
// ----------------------------------------------------------------

#include<iostream>
#include"save.h"
#include"STRING.h"

extern bool 관찰;

//--------
int main()
//--------
{
	save("메인.cpp");

	
	STRING s[5]{ "1","333","55555","22","4444", };

	관찰 = true;
	for (STRING& s : s)
		std::cout << s.size() << std::endl;
	관찰 = false;
}


======================================
저장시간:2024-11-13 16:50:16.9576378
======================================

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (10주 2일)
// ----------------------------------------------------------------
// 연산자 오버로딩( operator overloading )
// std::string을 흉내낸 STRING을 작성
// int를 흉내낸 INT를 작성하여 연산자를 오버로딩할 필요성
// ----------------------------------------------------------------
// "  " : 아주 낡고 오래된 약속.	=> hello '\0'
// string 안에는 두 가지 요소가 있음
// 1.글자수	2. 글자*
// ----------------------------------------------------------------

#include<iostream>
#include"save.h"
#include"STRING.h"

extern bool 관찰;

//--------
int main()
//--------
{
	save("메인.cpp");
	
	STRING s[5]{ "1","333","55555","22","4444", };

	// [문제] s를 길이 오름차순으로 정렬하라.
	관찰 = true;
	qsort(s, 5 , sizeof(STRING), [](const void* a, const void* b) {
		STRING& c = *(STRING*)a;
		STRING& d = *(STRING*)b;
		return static_cast<int>(c.size() - d.size());
		});

	관찰 = false;

	for (STRING& s : s)
		std::cout << s.size() << std::endl;

}

// ----------------------------------------------------------------
// 2024. 2학기 11.06 수         수78목78        (10주 2일)
// ----------------------------------------------------------------
// 연산자 오버로딩( operator overloading )
// std::string을 흉내낸 STRING을 작성
// int를 흉내낸 INT를 작성하여 연산자를 오버로딩할 필요성
// ----------------------------------------------------------------
// operator : 연산자
// int a = 2 + 3;
// 2, 3 : 피연산자(operand)
// + : 이항연산자(binary operator)
// ----------------------------------------------------------------
// X c = a K b;
// compiler
// 1. a.operatorK(b);
// 2. x.operator(a,b);
// ----------------------------------------------------------------

#include<iostream>
#include"save.h"
#include"STRING.h"

extern bool 관찰;

//--------
int main()
//--------
{
	save("메인.cpp");
	
	STRING s = { "The C++ Programming Language!" };
	std::cout << "더하기 전의 글자 수" << s.size() << std::endl;
	s = s + "참 재미있다.";
	std::cout << "더한 후의 글자 수 - " << s.size() << std::endl;
}
// STRING.cpp 코딩하기



<=================================================================
저장시간:2024-11-14 16:08:54.9825959

// -------------------------------------------------- 
//2024 2학기 11.14 수    수78 목78    (11주 1일)
//---------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 기말시험
// 12/18 수요일 15주 2일차 - 종강
//---------------------------------------------------
// 연산자 오버로딩( operator overloading ) 
// std::string을 흉내낸 STRING을 작성
// int를 흉내낸 INT를 작성하며 연산자를 오버로딩할 필요성
//---------------------------------------------------
// 메모
// 
#include<iostream>
#include<string>
#include"STRING.h"
#include"save.h"

extern bool 관찰;

int main()
{
	(*save)("11_14.cpp");

	관찰 = true;

	STRING s = { "The C++ Programming Language!" };

	std::cout << s.size() << std::endl;

	STRING c = s + " 참 재미있다.";                
	// 1. s.operator+(const char*) 를 제공하고 있는지?
	// 2. 전역함수 operator+(STRING,const char*)가 있는지?

	std::cout << "더한 후 글자 수 : " << c.size() << std::endl;
}
=================================================================>



<=================================================================
저장시간:2024-11-14 16:09:17.6911704

// -------------------------------------------------- 
//2024 2학기 11.14 수    수78 목78    (11주 1일)
//---------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 기말시험
// 12/18 수요일 15주 2일차 - 종강
//---------------------------------------------------
// 연산자 오버로딩( operator overloading ) 
// std::string을 흉내낸 STRING을 작성
// int를 흉내낸 INT를 작성하며 연산자를 오버로딩할 필요성
//---------------------------------------------------
// 메모
// 
#include<iostream>
#include<string>
#include"STRING.h"
#include"save.h"

extern bool 관찰;

int main()
{
	(*save)("11_14.cpp");

	관찰 = true;

	STRING s = { "The C++ Programming Language!" };

	std::cout << s.size() << std::endl;

	s = s + " 참 재미있다.";                
	// 1. s.operator+(const char*) 를 제공하고 있는지?
	// 2. 전역함수 operator+(STRING,const char*)가 있는지?

	std::cout << "더한 후 글자 수 : " << s.size() << std::endl;
}
=================================================================>



<=================================================================
저장시간:2024-11-14 16:41:56.7917564

// -------------------------------------------------- 
//2024 2학기 11.14 수    수78 목78    (11주 1일)
//---------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 기말시험
// 12/18 수요일 15주 2일차 - 종강
//---------------------------------------------------
// 연산자 오버로딩( operator overloading ) 
// std::string을 흉내낸 STRING을 작성
// int를 흉내낸 INT를 작성하며 연산자를 오버로딩할 필요성
//---------------------------------------------------
// 메모
// 1. s.operator+(const char*) 를 제공하고 있는지?
// 2. 전역함수 operator+(STRING,const char*)가 있는지?
#include<iostream>
#include<string>
#include"STRING.h"
#include"save.h"

extern bool 관찰;

int main()
{
	(*save)("11_14.cpp");
	//copy elision - RVO(Return Value Optimization)

	관찰 = true;

	STRING s = { "The C++ Programming Language!" };

	std::cout << s.size() << std::endl;

	s = " 참 재미있다." + s;
	

	std::cout << "더한 후 글자 수 : " << s.size() << std::endl;
}
=================================================================>



<=================================================================
저장시간:2024-11-14 16:42:30.4233825

// -------------------------------------------------- 
//2024 2학기 11.14 수    수78 목78    (11주 1일)
//---------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 기말시험
// 12/18 수요일 15주 2일차 - 종강
//---------------------------------------------------
// 연산자 오버로딩( operator overloading ) 
// std::string을 흉내낸 STRING을 작성
// int를 흉내낸 INT를 작성하며 연산자를 오버로딩할 필요성
//---------------------------------------------------
// 메모
// 1. s.operator+(const char*) 를 제공하고 있는지?
// 2. 전역함수 operator+(STRING,const char*)가 있는지?
#include<iostream>
#include<string>
#include"STRING.h"
#include"save.h"

extern bool 관찰;

int main()
{
	(*save)("11_14.cpp");
	//copy elision - RVO(Return Value Optimization)

	STRING s = { "The C++ Programming Language!" };

	std::cout << s.size() << std::endl;

	s = " 참 재미있다." + s;
	

	std::cout << "더한 후 글자 수 : " << s.size() << std::endl;
}
=================================================================>



<=================================================================
저장시간:2024-11-14 17:02:01.1459442

// -------------------------------------------------- 
//2024 2학기 11.14 수    수78 목78    (11주 1일)
//---------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 기말시험
// 12/18 수요일 15주 2일차 - 종강
//---------------------------------------------------
// 연산자 오버로딩( operator overloading ) 
// std::string을 흉내낸 STRING을 작성
// int를 흉내낸 INT를 작성하며 연산자를 오버로딩할 필요성
//---------------------------------------------------
// 메모
// 1. s.operator+(const char*) 를 제공하고 있는지?
// 2. 전역함수 operator+(STRING,const char*)가 있는지?
#include<iostream>
#include<string>
#include"STRING.h"
#include"save.h"

extern bool 관찰;

int main()
{
	(*save)("11_14.cpp");
	//copy elision - RVO(Return Value Optimization)

	std::cout << 1 << 2 << 3 << std::endl;

	STRING s = { "The C++ Programming Language!" };

	std::cout << s << std::endl;
}
=================================================================>



<=================================================================
저장시간:2024-11-14 17:05:12.0369356

// -------------------------------------------------- 
//2024 2학기 11.14 수    수78 목78    (11주 1일)
//---------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 기말시험
// 12/18 수요일 15주 2일차 - 종강
//---------------------------------------------------
// 연산자 오버로딩( operator overloading ) 
// std::string을 흉내낸 STRING을 작성
// int를 흉내낸 INT를 작성하며 연산자를 오버로딩할 필요성
//---------------------------------------------------
// 메모
// 1. s.operator+(const char*) 를 제공하고 있는지?
// 2. 전역함수 operator+(STRING,const char*)가 있는지?
#include<iostream>
#include<string>
#include"STRING.h"
#include"save.h"

extern bool 관찰;

int main()
{
	(*save)("11_14.cpp");
	
	std::string s{ "Hello, C++!" };
	for (int i{}; i < s.size(); ++i) {
		std::cout << s[i] << std::endl;
	}
}
=================================================================>


======================================
저장시간:2024-11-20 15:40:51.5526375
======================================

// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// 연산자 오버로딩( operator overloading ) 
// std::string을 흉내낸 STRING을 작성
// int를 흉내낸 INT를 작성하며 연산자를 오버로딩할 필요성
//--------------------------------------------------------
// 메모
// 1. s.operator+(const char*) 를 제공하고 있는지?
// 2. 전역함수 operator+(STRING,const char*)가 있는지?

#include<iostream>
#include<string>
#include"STRING.h"
#include"save.h"

extern bool 관찰;

int main()
{
	save("메인.cpp");

	std::string s{ "Hello, C++!" };

	s = "2024. 11. 20" + s;		// syntactic sugar
	// s = operator+( "2024. 11. 20", s);

	std::cout << s << std::endl;

	// [문제] 다음 코드가 의도대로 실행되게 하라.

}

======================================
저장시간:2024-11-20 16:01:18.1718891
======================================

// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// 연산자 오버로딩( operator overloading ) 
// std::string을 흉내낸 STRING을 작성
// int를 흉내낸 INT를 작성하며 연산자를 오버로딩할 필요성
//--------------------------------------------------------
// 메모
// 1. s.operator+(const char*) 를 제공하고 있는지?
// 2. 전역함수 operator+(STRING,const char*)가 있는지?

#include<iostream>
#include<string>
#include"STRING.h"
#include"save.h"

extern bool 관찰;

int main()
{
	save("메인.cpp");

	std::string s{ "Hello, C++!dasdasdasdadsdaaagaf" };

	// [문제] 다음 코드가 의도대로 실행되게 하라.
	for (int i = 0; i < s.size(); ++i)
		s[i] = toupper(s[i]);

}

======================================
저장시간:2024-11-20 16:02:16.9348824
======================================

// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// 연산자 오버로딩( operator overloading ) 
// std::string을 흉내낸 STRING을 작성
// int를 흉내낸 INT를 작성하며 연산자를 오버로딩할 필요성
//--------------------------------------------------------
// 메모
// 1. s.operator+(const char*) 를 제공하고 있는지?
// 2. 전역함수 operator+(STRING,const char*)가 있는지?

#include<iostream>
#include<string>
#include"STRING.h"
#include"save.h"

extern bool 관찰;

int main()
{
	save("메인.cpp");

	std::string s{ "Hello, C++!" };

	// [문제] 다음 코드가 의도대로 실행되게 하라.
	for (int i = 0; i < s.size(); ++i)
		s[i] = toupper(s[i]);

	std::cout << s << std::endl;
}

======================================
저장시간:2024-11-20 16:02:25.9700610
======================================

// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// 연산자 오버로딩( operator overloading ) 
// std::string을 흉내낸 STRING을 작성
// int를 흉내낸 INT를 작성하며 연산자를 오버로딩할 필요성
//--------------------------------------------------------
// 메모
// 1. s.operator+(const char*) 를 제공하고 있는지?
// 2. 전역함수 operator+(STRING,const char*)가 있는지?

#include<iostream>
#include<string>
#include"STRING.h"
#include"save.h"

extern bool 관찰;

int main()
{
	save("메인.cpp");

	std::string s{ "Hello, C++!efewfwefwefwefweff" };

	// [문제] 다음 코드가 의도대로 실행되게 하라.
	for (int i = 0; i < s.size(); ++i)
		s[i] = toupper(s[i]);

	std::cout << s << std::endl;
}

======================================
저장시간:2024-11-20 16:04:53.8574827
======================================

// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// movee semantics(이동의미론)
//--------------------------------------------------------
// 메모
// 1. s.operator+(const char*) 를 제공하고 있는지?
// 2. 전역함수 operator+(STRING,const char*)가 있는지?

#include<iostream>
#include<string>
#include"STRING.h"
#include"save.h"

extern bool 관찰;

int main()
{
	save("메인.cpp");

	std::string s1 = { "나는 문자열을 다룬다" };
	std::string s2 = s1;

	std::cout << s1 << std::endl;
	std::cout << s2 << std::endl;
}

======================================
저장시간:2024-11-20 16:06:30.5770919
======================================

// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// movee semantics(이동의미론)
//--------------------------------------------------------
// 메모
// 1. s.operator+(const char*) 를 제공하고 있는지?
// 2. 전역함수 operator+(STRING,const char*)가 있는지?

#include<iostream>
#include<string>
#include"STRING.h"
#include"save.h"

extern bool 관찰;

int main()
{
	save("메인.cpp");

	관찰 = true;
	STRING s1 = { "나는 문자열을 다룬다" };
	STRING s2 = s1;

	std::cout << s1 << std::endl;
	std::cout << s2 << std::endl;
}

======================================
저장시간:2024-11-20 16:07:26.3363235
======================================

// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// movee semantics(이동의미론)
//--------------------------------------------------------
// 메모
// 1. s.operator+(const char*) 를 제공하고 있는지?
// 2. 전역함수 operator+(STRING,const char*)가 있는지?

#include<iostream>
#include<string>
#include"STRING.h"
#include"save.h"

extern bool 관찰;

int main()
{
	save("메인.cpp");

	관찰 = true;
	std::string s1 = { "나는 문자열을 다룬다" };
	std::string s2 = move(s1);

	std::cout << s1 << std::endl;
	std::cout << s2 << std::endl;
}

======================================
저장시간:2024-11-20 16:48:35.3848540
======================================

// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// move semantics(이동의미론)
//--------------------------------------------------------
// 메모
// 1. &             : ampersand
// 2. int n;
//    int* p = &n;  : address of n
// 3. int& r = n;   : reference
// 4. int&& rr = 3; : rvalue-reference

#include<iostream>
#include<string>
#include"STRING.h"
#include"save.h"

extern bool 관찰;

int main()
{
	save("메인.cpp");

	STRING s1 = { "나는 문자열을 다룬다" };
	STRING s2 = std::move(s1);

	std::cout << s1 << std::endl;	// s1이 xvalue가 되기에 사용하면 안됨
	std::cout << s2 << std::endl;
}

======================================
저장시간:2024-11-20 16:54:45.5700781
======================================

// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// move semantics(이동의미론)
//--------------------------------------------------------
// 메모
// 1. &             : ampersand
// 2. int n;
//    int* p = &n;  : address of n
// 3. int& r = n;   : reference
// 4. int&& rr = 3; : rvalue-reference

#include <iostream>
#include <algorithm>
#include "STRING.h"
#include "save.h"

extern bool 관찰;

int main()
{
	save("메인.cpp");

	STRING s[5] = { "1","333","55555","22","4444" };

	// 길이 오름차순으로 정렬한다. 
	std::sort(std::begin(s), std::end(s), [](const STRING& a, const STRING& b) {
		return a.size() < b.size();
		} );

	for (const STRING& s : s)
		std::cout << s << std::endl;
}

======================================
저장시간:2024-11-20 16:54:55.5617675
======================================

// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// move semantics(이동의미론)
//--------------------------------------------------------
// 메모
// 1. &             : ampersand
// 2. int n;
//    int* p = &n;  : address of n
// 3. int& r = n;   : reference
// 4. int&& rr = 3; : rvalue-reference

#include <iostream>
#include <algorithm>
#include "STRING.h"
#include "save.h"

extern bool 관찰;

int main()
{
	save("메인.cpp");

	STRING s[5] = { "1","333","55555","22","4444" };

	// 길이 오름차순으로 정렬한다. 
	관찰 = true;
	std::sort(std::begin(s), std::end(s), [](const STRING& a, const STRING& b) {
		return a.size() < b.size();
		} );
	관찰 = false;

	for (const STRING& s : s)
		std::cout << s << std::endl;
}

======================================
저장시간:2024-11-20 16:57:55.7430514
======================================

// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// move semantics(이동의미론)
//--------------------------------------------------------
// 메모
// 1. &             : ampersand
// 2. int n;
//    int* p = &n;  : address of n
// 3. int& r = n;   : reference
// 4. int&& rr = 3; : rvalue-reference

#include <iostream>
#include <algorithm>
#include "STRING.h"
#include "save.h"

extern bool 관찰;

int main()
{
	save("메인.cpp");
	save("STRING.h");
	save("STRING.cpp");

	STRING s[5] = { "1","333","55555","22","4444" };

	// 길이 오름차순으로 정렬한다. 
	관찰 = true;
	std::sort(std::begin(s), std::end(s), [](const STRING& a, const STRING& b) {
		return a.size() < b.size();
		} );
	관찰 = false;

	for (const STRING& s : s)
		std::cout << s << std::endl;
}

======================================
저장시간:2024-11-20 16:57:55.8207424
======================================

//----------------------------------------------------
//STRING.h
//표준 std::string의 동작을 흉내내본 클래스
//헤더에서는 클래스를 선언한다
// 
// 2024.11.13
//----------------------------------------------------
#pragma once

class STRING {

public:
	STRING() = default;  // 생성자 
	STRING(const char* str);
	//11.24
	STRING(size_t); //  +연산을 위해 새로 작성 2024.11.14
	~STRING();

	STRING(const STRING&); //복사생성자
	STRING& operator=(const STRING&); //복사할당연산자

	// 2024. 11. 20 이동생성자와 이동할당연산자
	STRING(STRING&&);
	STRING& operator=(STRING&&);

	//연산자 오버로딩 2024.11.13
	STRING operator+(const char*) const;

	// 2024. 11. 14
	char operator[](size_t) const;
	// 2024. 11. 20
	char& operator[](size_t);		// const를 제거해주어 오버로딩이 가능하도록 하자

	size_t size() const;

	//여기는 STINRG의 친구들이 들어갈 자리 
	friend STRING operator+(const char* s, const STRING& STR);

	//입출력 연산자 오버로딩은 반드시 friend로 선언하자
	friend std::ostream& operator<<(std::ostream&, const STRING);

private:
	size_t size_str{};
	char* p{};
};

======================================
저장시간:2024-11-20 16:57:55.8515673
======================================

//----------------------------------------------------
//STRING.cpp
//표준 std::string의 동작을 흉내내본 클래스
//여기에서는 클래스 멤버함수를 정의한다
// 
// s=str / num=size_str
// 2024.11.13
//----------------------------------------------------
#include<cstring>
#include<iostream>
#include"STRING.h"

bool 관찰{ false };


STRING::STRING(const char* str)
	:size_str{ strlen(str) }
{
	p = new char[size_str];
	memcpy(p, str, size_str);

	if (관찰) {
		std::cout << "생성자 - " << size_str << " / 번지 -" << this << std::endl;
	}
}

//2024.11.14 operator+dptj 필요하여 새로 만듦
STRING::STRING(size_t n)
	:size_str{ n }
{
	p = new char[size_str];
	if (관찰) {
		std::cout << "생성자(char*) - " << size_str << " / 번지 -" << this << std::endl;
	}
}
STRING::~STRING()
{
	if (관찰) {
		std::cout << "소멸자 - " << size_str << " / 번지 -" << this << std::endl;
	}
	delete[] p;
}

STRING::STRING(const STRING& other) // 복사생성자
	:size_str{ other.size_str }
{
	p = new char[size_str];
	memcpy(p, other.p, size_str);
	// *this=other 할당을 잘 코딩했다면 이렇게 할 수 있다

	if (관찰) {
		std::cout << "복사생성자 - " << size_str << " / 번지 -" << this << std::endl;
	}
}

STRING& STRING::operator=(const STRING& other)
{
	if (this == &other) {
		return *this;
	}

	delete[] p;
	size_str = other.size_str;
	p = new char[size_str];
	memcpy(p, other.p, size_str);
	if (관찰) {
		std::cout << "복사할당생성자 - " << size_str << " / 번지 -" << this << std::endl;

	}
}

// 2024. 11. 20 이동생성자와 이동할당연산자
STRING::STRING(STRING&& other) 
	: size_str{ other.size_str }, p{ other.p }
{
	other.size_str = 0;
	other.p = nullptr;
	if (관찰)
		std::cout << "이동생성자 - " << size_str << " / 번지 -" << this << std::endl;
}

STRING& STRING::operator=(STRING&& other)
{
	if (this == &other)
		return *this;

	size_str = other.size_str;
	p = other.p;

	other.size_str = 0;
	other.p = nullptr;

	if (관찰)
		std::cout << "이동할당생성자 - " << size_str << " / 번지 -" << this << std::endl;

	return *this;
}

//11.14
STRING STRING::operator+(const char* s) const
{
	/*char* temp;
	int size = strlen(s)+size_str;
	temp = new char[size];
	memcpy(temp, p, size_str);
	memcpy(temp + size_str, s, strlen(s));

	return temp;*/  //내가 한거

	// 이항연산자의 피연산자 2개가 갖고 있는 글자를 담을 수 있는 임시 STRING 객체를 생성한다.
	STRING temp{ size_str + strlen(s) };
	//왼쪽 피연산자의 내용을 copy
	memcpy(temp.p, p, size_str);
	//오른쪽 피연산자의 내용을 copy
	memcpy(temp.p + size_str, s, strlen(s));

	return temp;
}

size_t STRING::size() const
{
	return size_str;
}

STRING operator+(const char* s, const STRING& STR)
{
	size_t len{ strlen(s) };
	STRING temp{ len + STR.size_str };

	memcpy(temp.p, s, len);
	memcpy(temp.p + len, STR.p, STR.size_str);

	return temp;
}

char STRING::operator[](size_t index) const
{
	return p[index];
}

// 2024. 11. 20
char& STRING::operator[](size_t idx)
{
	return p[idx];
}




std::ostream& operator<<(std::ostream& os, const STRING STR)
{
	for (int i{}; i < STR.size_str; ++i) {
		os << STR.p[i];
	}
	return os;
}


======================================
저장시간:2024-11-20 16:59:38.2206899
======================================

// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// 
//--------------------------------------------------------
// 메모
//--------------------------------------------------------

#include <iostream>
#include "save.h"

int main()
{
	save("메인.cpp");

	int n{ 1 };

	std::cout << ++n << std::endl;
}


// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// 
//--------------------------------------------------------
// 메모
//--------------------------------------------------------

#include <iostream>
#include "save.h"

class INT {
public:
	INT(int n) : n{ n } {}

	friend std::ostream& operator<<(std::ostream& os, const INT& i) {
		return os << i.n;
	}
private:
	int n{};
};

int main()
{
	save("메인.cpp");

	// [문제] class INT를 코딩하여 의도대로 실행되게 하라.

	INT n{ 1 };

	std::cout << ++n << std::endl;		// operator++()를 코딩하면 해결되겠다.
}

======================================
저장시간:2024-11-20 17:15:07.8657100
======================================

// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// 
//--------------------------------------------------------
// 메모
//--------------------------------------------------------

#include <iostream>
#include "save.h"

class INT {
public:
	INT(int n) : n{ n } {}

	INT& operator++() {
		++n;	// 나를 1증가한다
		return *this;	// 1증가한 나를 리턴한다
	}

	friend std::ostream& operator<<(std::ostream& os, const INT& i) {
		return os << i.n;
	}

private:
	int n{};
};

int main()
{
	save("메인.cpp");

	// [문제] class INT를 코딩하여 의도대로 실행되게 하라.

	INT n{ 1 };

	// operator++()를 코딩하면 해결되겠다.
	std::cout << n.operator++() << std::endl;
}

======================================
저장시간:2024-11-20 17:19:32.6536040
======================================

// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// 
//--------------------------------------------------------
// 메모
//--------------------------------------------------------

#include <iostream>
#include "save.h"

class INT {
public:
	INT(int n) : n{ n } {}

	INT& operator++() {
		++n;	// 나를 1증가한다
		return *this;	// 1증가한 나를 리턴한다
	}

	// post-increment
	INT operator++(int) {
		INT old = *this;	// 현재의 나를 저장한다
		++(*this);			// 나를 1증가시킨다
		return old;			// 증가되기전의 나를 리턴한다
	}

	// operator int( ) const { return n: }
	friend std::ostream& operator<<(std::ostream& os, const INT& i) {
		return os << i.n;
	}

private:
	int n{};
};

int main()
{
	save("메인.cpp");

	// [문제] class INT를 코딩하여 의도대로 실행되게 하라.

	INT n{ 1 };

	// operator++()를 코딩하면 해결되겠다.
	std::cout << n.operator++() << std::endl;
}

======================================
저장시간:2024-11-21 15:32:24.2655250
======================================

// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// 
//--------------------------------------------------------
// 메모
//--------------------------------------------------------

#include <iostream>
#include "save.h"

class INT {
public:
	INT(int n) : n{ n } {}

	INT& operator++() {
		++n;	// 나를 1증가한다
		return *this;	// 1증가한 나를 리턴한다
	}

	// post-increment
	INT operator++(int) {
		INT old = *this;	// 현재의 나를 저장한다
		++(*this);			// 나를 1증가시킨다
		return old;			// 증가되기전의 나를 리턴한다
	}

	// operator int( ) const { return n: }
	friend std::ostream& operator<<(std::ostream& os, const INT& i) {
		return os << i.n;
	}

private:
	int n{};
};

int main()
{
	save("메인.cpp");

	// [문제] class INT를 코딩하여 의도대로 실행되게 하라.

	INT n{ 1 };

	std::cout << n++ << std::endl;
	std::cout << n << std::endl;
}


// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// 
//--------------------------------------------------------
// 메모
//--------------------------------------------------------

#include <iostream>
#include "save.h"

class INT {
public:
	INT(int n) : n{ n } {}

	INT& operator++() {
		++n;	// 나를 1증가한다
		return *this;	// 1증가한 나를 리턴한다
	}

	// post-increment
	const INT operator++(int) {		// const를 붙힌다면 INT로 가능했던 동작이 불가해짐.
		INT old = *this;	// 현재의 나를 저장한다
		++(*this);			// 나를 1증가시킨다
		return old;			// 증가되기전의 나를 리턴한다
	}

	// operator int( ) const { return n: }
	friend std::ostream& operator<<(std::ostream& os, const INT& i) {
		return os << i.n;
	}

private:
	int n{};
};

int main()
{
	save("메인.cpp");

	// [문제] class INT를 코딩하여 의도대로 실행되게 하라.

	INT n{ 1 };

	std::cout << n++ ++ << std::endl;	// 진짜 int는 불가	// 식이 수정할 수 있는 value여야 합니다.
	std::cout << n << std::endl;
}



// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// callable type( 호출가능타입 ) - 함수, 멤버함수, 람다, function object
//--------------------------------------------------------
// 메모
//--------------------------------------------------------

#include <iostream>
#include "save.h"



int main()
{
	save("메인.cpp");

	int a, b;
	class Dog {};
	Dog c;
	a = b;	// 이곳에 빨간줄이 생기지 않는 것을 a와b의 타입이 같다고 한다.
	c = b;	// 이 경우에는 타입이 달라 빨간줄이 생긴다.
}

======================================
저장시간:2024-11-21 15:57:05.6545177
======================================

// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// callable type( 호출가능타입 ) - 함수, 멤버함수, 람다, function object
//--------------------------------------------------------
// 메모
//--------------------------------------------------------

#include <iostream>
#include <random>
#include <print>
#include "save.h"
using namespace std;

std::default_random_engine dre;
std::uniform_int_distribution uidAge{ 1, 99 };
std::uniform_int_distribution<int> uidName{ 'a','z' };
std::uniform_int_distribution uidNameLen{ 3,30 };

class Dog {
public:
	Dog() {
		int len = uidNameLen(dre);
		for (int i = 0; i < len; ++i)
			name += uidName(dre);
	}

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		print(os, "나이-{:>2}, 이름-{}", dog.age, dog.name);
		return os;
	}
private:
	int age{uidAge(dre)};
	std::string name{};
};

int main()
{
	save("메인.cpp");

	Dog dogs[10];

	for (const Dog& dog : dogs)
		std::cout << dog << std::endl;
}



// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// callable type( 호출가능타입 ) - 함수, 멤버함수, 람다, function object
//--------------------------------------------------------
// 메모
// sort의 마지막에는 호출가능타입을 넣는다.
//--------------------------------------------------------

#include <iostream>
#include <random>
#include <print>
#include <algorithm>
#include "save.h"
using namespace std;

std::default_random_engine dre;
std::uniform_int_distribution uidAge{ 1, 99 };
std::uniform_int_distribution<int> uidName{ 'a','z' };	
std::uniform_int_distribution uidNameLen{ 3,30 };

class Dog {
public:
	Dog() {
		int len = uidNameLen(dre);
		for (int i = 0; i < len; ++i)
			name += uidName(dre);
	}

	int getAge() const {
		return age;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		print(os, "나이-{:>2}, 이름-{}", dog.age, dog.name);
		return os;
	}
private:
	int age{uidAge(dre)};
	std::string name{};
};

bool 나이순(const Dog& a, const Dog& b)
{
	// < - less than operator가 default 정렬 연산자이다.
	return a.getAge() < b.getAge();
}

//-----------
int main()
//-----------
{
	//save("메인.cpp");

	Dog dogs[10];

	// 나이 오름차순으로 정렬하라.
	sort(begin(dogs), end(dogs), 나이순 );		// 함수

	for (const Dog& dog : dogs)
		std::cout << dog << std::endl;
}


// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// callable type( 호출가능타입 ) - 함수, 멤버함수, 람다, function object
//--------------------------------------------------------
// 메모
// sort의 마지막에는 호출가능타입을 넣는다.
//--------------------------------------------------------

#include <iostream>
#include <random>
#include <print>
#include <algorithm>
#include "save.h"
using namespace std;

std::default_random_engine dre;
std::uniform_int_distribution uidAge{ 1, 99 };
std::uniform_int_distribution<int> uidName{ 'a','z' };	
std::uniform_int_distribution uidNameLen{ 3,30 };

class Dog {
public:
	Dog() {
		int len = uidNameLen(dre);
		for (int i = 0; i < len; ++i)
			name += uidName(dre);
	}

	int getAge() const {
		return age;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		print(os, "나이-{:>2}, 이름-{}", dog.age, dog.name);
		return os;
	}
private:
	int age{uidAge(dre)};
	std::string name{};
};

bool 나이순(const Dog& a, const Dog& b)
{
	// < - less than operator가 default 정렬 연산자이다.
	return a.getAge() < b.getAge();
}

//-----------
int main()
//-----------
{
	//save("메인.cpp");

	Dog dogs[10];

	// 나이 오름차순으로 정렬하라.
	sort(begin(dogs), end(dogs), 나이순 );		// 함수
	sort(begin(dogs), end(dogs), [] (const Dog& a,const Dog& b){

	})

	for (const Dog& dog : dogs)
		std::cout << dog << std::endl;
}


======================================
저장시간:2024-11-21 16:47:38.0626717
======================================

// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// callable type( 호출가능타입 ) - 함수, 멤버함수, 람다, function object
//--------------------------------------------------------
// 메모
// sort의 마지막에는 호출가능타입을 넣는다.
//--------------------------------------------------------

#include <iostream>
#include <random>
#include <print>
#include <algorithm>
#include "save.h"
using namespace std;

std::default_random_engine dre;
std::uniform_int_distribution uidAge{ 1, 99 };
std::uniform_int_distribution<int> uidName{ 'a','z' };	
std::uniform_int_distribution uidNameLen{ 3,30 };

class Dog {
public:
	Dog() {
		int len = uidNameLen(dre);
		for (int i = 0; i < len; ++i)
			name += uidName(dre);
	}

	int getAge() const {
		return age;
	}

	// 함수호출연산자를 오버로딩하면 이 class 객체는 호출가능하게 된다.
	bool operator()(const Dog& lhs, const Dog& rhs) const {
		return lhs.age < rhs.age;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		print(os, "나이-{:>2}, 이름-{}", dog.age, dog.name);
		return os;
	}
private:
	int age{uidAge(dre)};
	std::string name{};
};

bool 나이순(const Dog& a, const Dog& b)
{
	// < - less than operator가 default 정렬 연산자이다.
	return a.getAge() < b.getAge();
}

//-----------
int main()
//-----------
{
	save("메인.cpp");

	Dog dogs[10];

	// 나이 오름차순으로 정렬하라.
	Dog dog;
	sort(begin(dogs), end(dogs), dog);

	for (const Dog& dog : dogs)
		std::cout << dog << std::endl;
}



======================================
저장시간:2024-11-21 16:52:54.8128412
======================================

// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// callable type( 호출가능타입 ) - 함수, 멤버함수, 람다, function object
//--------------------------------------------------------
// 메모
// sort의 마지막에는 호출가능타입을 넣는다.
//--------------------------------------------------------

#include <iostream>
#include <random>
#include <print>
#include <algorithm>
#include "save.h"
using namespace std;

std::default_random_engine dre;
std::uniform_int_distribution uidAge{ 1, 99 };
std::uniform_int_distribution<int> uidName{ 'a','z' };	
std::uniform_int_distribution uidNameLen{ 3,30 };

class Dog {
public:
	Dog() {
		int len = uidNameLen(dre);
		for (int i = 0; i < len; ++i)
			name += uidName(dre);
	}

	int getAge() const {
		return age;
	}

	// 함수호출연산자를 오버로딩하면 이 class 객체는 호출가능하게 된다.
	// 함수호출연산자를 오버로딩한 class의 객체를 function object 라고 한다.
	bool operator()(const Dog& lhs, const Dog& rhs) const {
		return lhs.age < rhs.age;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		print(os, "나이-{:>2}, 이름-{}", dog.age, dog.name);
		return os;
	}
private:
	int age{uidAge(dre)};
	std::string name{};
};

bool 나이순(const Dog& a, const Dog& b)
{
	// < - less than operator가 default 정렬 연산자이다.
	return a.getAge() < b.getAge();
}

//-----------
int main()
//-----------
{
	save("메인.cpp");

	Dog dogs[10];

	// 나이 오름차순으로 정렬하라.
	Dog dog;
	sort(begin(dogs), end(dogs), Dog{});

	for (const Dog& dog : dogs)
		std::cout << dog << std::endl;
}



======================================
저장시간:2024-11-21 16:53:46.4696955
======================================

// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// callable type( 호출가능타입 ) - 함수, 멤버함수, 람다, function object
//--------------------------------------------------------
// 메모
// sort의 마지막에는 호출가능타입을 넣는다.
//--------------------------------------------------------

#include <iostream>
#include <random>
#include <print>
#include <algorithm>
#include "save.h"
using namespace std;

std::default_random_engine dre;
std::uniform_int_distribution uidAge{ 1, 99 };
std::uniform_int_distribution<int> uidName{ 'a','z' };	
std::uniform_int_distribution uidNameLen{ 3,30 };

class Dog {
public:
	Dog() {
		int len = uidNameLen(dre);
		for (int i = 0; i < len; ++i)
			name += uidName(dre);
	}

	int getAge() const {
		return age;
	}

	// 함수호출연산자를 오버로딩하면 이 class 객체는 호출가능하게 된다.
	// 함수호출연산자를 오버로딩한 class의 객체를 function object 라고 한다.
	bool operator()(const Dog& lhs, const Dog& rhs) const {
		return lhs.age < rhs.age;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		print(os, "나이-{:>2}, 이름-{}", dog.age, dog.name);
		return os;
	}
private:
	int age{uidAge(dre)};
	std::string name{};
};

bool 나이순(const Dog& a, const Dog& b)
{
	// < - less than operator가 default 정렬 연산자이다.
	return a.getAge() < b.getAge();
}

//-----------
int main()
//-----------
{
	save("메인.cpp");

	Dog dogs[1000];

	for (const Dog& dog : dogs)
		cout << dog << endl;
}



======================================
저장시간:2024-11-21 16:59:41.9843785
======================================

// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// callable type( 호출가능타입 ) - 함수, 멤버함수, 람다, function object
//--------------------------------------------------------
// 메모
// sort의 마지막에는 호출가능타입을 넣는다.
//--------------------------------------------------------

#include <iostream>
#include <random>
#include <print>
#include <algorithm>
#include <fstream>
#include "save.h"
using namespace std;

std::default_random_engine dre;
std::uniform_int_distribution uidAge{ 1, 99 };
std::uniform_int_distribution<int> uidName{ 'a','z' };	
std::uniform_int_distribution uidNameLen{ 3,30 };

class Dog {
public:
	Dog() {
		int len = uidNameLen(dre);
		for (int i = 0; i < len; ++i)
			name += uidName(dre);
	}

	int getAge() const {
		return age;
	}

	// 함수호출연산자를 오버로딩하면 이 class 객체는 호출가능하게 된다.
	// 함수호출연산자를 오버로딩한 class의 객체를 function object 라고 한다.
	bool operator()(const Dog& lhs, const Dog& rhs) const {
		return lhs.age < rhs.age;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		print(os, "나이-{:>2}, 이름-{}", dog.age, dog.name);
		return os;
	}
private:
	int age{uidAge(dre)};
	std::string name{};
};

bool 나이순(const Dog& a, const Dog& b)
{
	// < - less than operator가 default 정렬 연산자이다.
	return a.getAge() < b.getAge();
}

//-----------
int main()
//-----------
{
	save("메인.cpp");

	Dog dogs[1000];

	// [문제] 파일에 dogs의 정보를 저장한다.
	ofstream out{ "개천마리" };

	for (const Dog& dog : dogs)
		out << dog << endl;

}



======================================
저장시간:2024-11-21 17:02:14.1662480
======================================

// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// callable type( 호출가능타입 ) - 함수, 멤버함수, 람다, function object
//--------------------------------------------------------
// 메모
// sort의 마지막에는 호출가능타입을 넣는다.
//--------------------------------------------------------

#include <iostream>
#include <random>
#include <print>
#include <algorithm>
#include <fstream>
#include "save.h"
using namespace std;

std::default_random_engine dre;
std::uniform_int_distribution uidAge{ 1, 99 };
std::uniform_int_distribution<int> uidName{ 'a','z' };	
std::uniform_int_distribution uidNameLen{ 3,30 };

class Dog {
public:
	Dog() {
		int len = uidNameLen(dre);
		for (int i = 0; i < len; ++i)
			name += uidName(dre);
	}

	int getAge() const {
		return age;
	}

	// 함수호출연산자를 오버로딩하면 이 class 객체는 호출가능하게 된다.
	// 함수호출연산자를 오버로딩한 class의 객체를 function object 라고 한다.
	bool operator()(const Dog& lhs, const Dog& rhs) const {
		return lhs.age < rhs.age;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		os << dog.age << " " << dog.name << " ";
		return os;
	}
private:
	int age{uidAge(dre)};
	std::string name{};
};

bool 나이순(const Dog& a, const Dog& b)
{
	// < - less than operator가 default 정렬 연산자이다.
	return a.getAge() < b.getAge();
}

//-----------
int main()
//-----------
{
	save("메인.cpp");

	Dog dogs[1000];

	// [문제] 파일에 dogs의 정보를 저장한다.
	ofstream out{ "개천마리" };

	for (const Dog& dog : dogs)
		out << dog << endl;

}



======================================
저장시간:2024-11-21 17:03:05.5340472
======================================

// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// callable type( 호출가능타입 ) - 함수, 멤버함수, 람다, function object
//--------------------------------------------------------
// 메모
// sort의 마지막에는 호출가능타입을 넣는다.
//--------------------------------------------------------

#include <iostream>
#include <random>
#include <print>
#include <algorithm>
#include <fstream>
#include "save.h"
using namespace std;

std::default_random_engine dre;
std::uniform_int_distribution uidAge{ 1, 99 };
std::uniform_int_distribution<int> uidName{ 'a','z' };	
std::uniform_int_distribution uidNameLen{ 3,30 };

class Dog {
public:
	Dog() {
		int len = uidNameLen(dre);
		for (int i = 0; i < len; ++i)
			name += uidName(dre);
	}

	int getAge() const {
		return age;
	}

	// 함수호출연산자를 오버로딩하면 이 class 객체는 호출가능하게 된다.
	// 함수호출연산자를 오버로딩한 class의 객체를 function object 라고 한다.
	bool operator()(const Dog& lhs, const Dog& rhs) const {
		return lhs.age < rhs.age;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		os << dog.age << " " << dog.name << " ";
		return os;
	}
private:
	int age{uidAge(dre)};
	std::string name{};
};

bool 나이순(const Dog& a, const Dog& b)
{
	// < - less than operator가 default 정렬 연산자이다.
	return a.getAge() < b.getAge();
}

//-----------
int main()
//-----------
{
	save("메인.cpp");

	Dog dogs[1000];

	// [문제] 파일에 dogs의 정보를 저장한다.
	ofstream out{ "개천마리" };

	for (const Dog& dog : dogs)
		out << dog << endl;

}



======================================
저장시간:2024-11-21 17:18:24.2952280
======================================

// -------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험
//--------------------------------------------------------
// callable type( 호출가능타입 ) - 함수, 멤버함수, 람다, function object
//--------------------------------------------------------
// 메모
// sort의 마지막에는 호출가능타입을 넣는다.
//--------------------------------------------------------

#include <iostream>
#include <random>
#include <print>
#include <algorithm>
#include <fstream>
#include "save.h"
using namespace std;

std::default_random_engine dre;
std::uniform_int_distribution uidAge{ 1, 99 };
std::uniform_int_distribution<int> uidName{ 'a','z' };	
std::uniform_int_distribution uidNameLen{ 3,30 };

class Dog {
public:
	Dog() {
		int len = uidNameLen(dre);
		for (int i = 0; i < len; ++i)
			name += uidName(dre);
	}

	int getAge() const {
		return age;
	}

	// 함수호출연산자를 오버로딩하면 이 class 객체는 호출가능하게 된다.
	// 함수호출연산자를 오버로딩한 class의 객체를 function object 라고 한다.
	bool operator()(const Dog& lhs, const Dog& rhs) const {
		return lhs.age < rhs.age;
	}

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		os << dog.age << " " << dog.name << " ";
		return os;
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		return is >> dog.age >> dog.name;
	}

private:
	int age{uidAge(dre)};
	std::string name{};
};

bool 나이순(const Dog& a, const Dog& b)
{
	// < - less than operator가 default 정렬 연산자이다.
	return a.getAge() < b.getAge();
}

//-----------
int main()
//-----------
{
	save("메인.cpp");



	// [문제] 파일 "개천마리" 에는 class Dog 객체 1000개가 저장되어 있다.
	// 메모리로 다 읽어 와라
	ifstream in{ "개천마리" };
	if (not in)
		return 999;

	Dog dogs[1000];

	for (Dog& dog : dogs) {
		in >> dog;
	}

	// [문제] qsort로 나이순 오름차순으로 정렬하라.

	// 화면에 정렬된 Dog를 출력하라.
	for (const Dog& dog : dogs)
		cout << dog << '\n';

}



======================================
저장시간:2024-11-27 17:07:48.1580372
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> 장소변경예정
// 
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속
//--------------------------------------------------------------------
// 메모
// virtual C++ 핵심키워드 / 그 전의 핵심키워드는 &와 const
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class Animal {
	int a;
};

class Dog : public Animal {
	double b;
};

//-----------
int main()
//-----------
{
	save("메인.cpp");

	// 부모자식객체의 메모리 크기를 확인해본다.
	cout << "Animal의 크기 - " << sizeof Animal << endl;
	cout << "Dog의 크기 - " << sizeof Dog << endl;
}



======================================
저장시간:2024-11-27 17:18:31.8284634
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (11주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> 장소변경예정
// 
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속
//--------------------------------------------------------------------
// 메모
// virtual C++ 핵심키워드 / 그 전의 핵심키워드는 &와 const
// 부모에게 상속받은 데이터는 절대로 자식이 건드릴 수 없다.
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class Animal {
public:
	Animal() {
		cout << "Animal 생성자" << endl;
	}
	~Animal() {
		cout << "Animal 소멸자" << endl;
	}
private:
	int a;
};

class Dog : public Animal {
public:
	Dog() {
		cout << "Dog 생성자" << endl;
	}
	~Dog() {
		cout << "Dog 소멸자" << endl;
	}
private:
	double b;
};

//-----------
int main()
//-----------
{
	save("메인.cpp");

	// 부모자식객체의 메모리 크기를 확인해본다.
	cout << "Animal의 크기 - " << sizeof Animal << endl;
	cout << "Dog의 크기 - " << sizeof Dog << endl;

	// 자식객체가 확보한 메모리에는 부모의 메모리가 포함되어 있다.

	// [확인] 생성자와 소멸자의 호출을 관찰한다.
	Dog dog;
}



======================================
저장시간:2024-11-28 16:20:09.0353530
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> 장소변경예정
// 
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속(inheritance)
//--------------------------------------------------------------------
// 메모
// 클래스 상속의 이유
// 1. 코드 재사용
// 2. 다형성을 구현(dynamic binding) polymorphism
// C++ 핵심 키워드
// 1.const, &
// 2.virtual -> polymorphism
// 3.template -> generic program	(고학년때)
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class BankString : public string {
public:
	// BankString(const char* s) : string{ s } {}

	friend ostream& operator<<( ostream& os, BankString& bs) {
		for (int i = 0; i < bs.size(); ++i) {
			if ( isdigit(bs.operator[](i)) )
				bs.operator[](i) = '*';
		}

		return os;
	}
};

//-----------
int main()
//-----------
{
	save("메인.cpp");

	// [문제] 은행에서 사용할 string이다.
	// 저장한 string의 내용을 화면에 출력할 때 숫자를 '*'로 바꾸어 출력하고 싶다.
	// 다음 프로그램이 문제없이 실행되게 하자

	BankString s{ "2024년 11월 28일" };

	cout << s << endl;	// ****년 **월 **일
}



======================================
저장시간:2024-11-28 16:20:34.6211544
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> 장소변경예정
// 
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속(inheritance)
//--------------------------------------------------------------------
// 메모
// 클래스 상속의 이유
// 1. 코드 재사용
// 2. 다형성을 구현(dynamic binding) polymorphism

// C++ 핵심 키워드
// 1.const, &
// 2.virtual -> polymorphism
// 3.template -> generic program	(고학년때)
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class BankString : public string {
public:
	// BankString(const char* s) : string{ s } {}

	friend ostream& operator<<( ostream& os, BankString& bs) {
		for (int i = 0; i < bs.size(); ++i) {
			if ( isdigit(bs.operator[](i)) )
				bs.operator[](i) = '*';
		}
		os << bs;
		return os;
	}
};

//-----------
int main()
//-----------
{
	save("메인.cpp");

	// [문제] 은행에서 사용할 string이다.
	// 저장한 string의 내용을 화면에 출력할 때 숫자를 '*'로 바꾸어 출력하고 싶다.
	// 다음 프로그램이 문제없이 실행되게 하자

	BankString s{ "2024년 11월 28일" };

	cout << s << endl;	// ****년 **월 **일
}



======================================
저장시간:2024-11-28 16:22:22.4940857
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> 장소변경예정
// 
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속(inheritance)
//--------------------------------------------------------------------
// 메모
// 클래스 상속의 이유
// 1. 코드 재사용
// 2. 다형성을 구현(dynamic binding) polymorphism

// C++ 핵심 키워드
// 1.const, &
// 2.virtual -> polymorphism
// 3.template -> generic program	(고학년때)
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class BankString : public string {
public:
	// BankString(const char* s) : string{ s } {}

	friend ostream& operator<<( ostream& os, BankString& bs) {
		for (int i = 0; i < bs.size(); ++i) {
			if ( isdigit(bs.operator[](i)) )
				bs.operator[](i) = '*';
		}
		os << bs.data();
		return os;
	}
};

//-----------
int main()
//-----------
{
	save("메인.cpp");

	// [문제] 은행에서 사용할 string이다.
	// 저장한 string의 내용을 화면에 출력할 때 숫자를 '*'로 바꾸어 출력하고 싶다.
	// 다음 프로그램이 문제없이 실행되게 하자

	BankString s{ "2024년 11월 28일" };

	cout << s << endl;	// ****년 **월 **일
}



======================================
저장시간:2024-11-28 16:23:59.2881379
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> 장소변경예정
// 
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속(inheritance)
//--------------------------------------------------------------------
// 메모
// 클래스 상속의 이유
// 1. 코드 재사용
// 2. 다형성을 구현(dynamic binding) polymorphism

// C++ 핵심 키워드
// 1.const, &
// 2.virtual -> polymorphism
// 3.template -> generic program	(고학년때)
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class BankString : public string {
public:
	// BankString(const char* s) : string{ s } {}

	friend ostream& operator<<( ostream& os, BankString& bs) {
		for (int i = 0; i < bs.size(); ++i) {
			if ( isdigit(bs.operator[](i)) )
				bs.operator[](i) = '*';
		}
		os << bs.data();
		return os;
	}
};

//-----------
int main()
//-----------
{
	save("메인.cpp");

	// [문제] 은행에서 사용할 string이다.
	// 저장한 string의 내용을 화면에 출력할 때 숫자를 '*'로 바꾸어 출력하고 싶다.
	// 다음 프로그램이 문제없이 실행되게 하자

	BankString s{ "2024년 11월 28일" };

	s += "2025년에는 로또 1등되게 해주세요";

	cout << s << endl;	// ****년 **월 **일
}



======================================
저장시간:2024-11-28 16:42:06.6131694
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> 장소변경예정
// 
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속(inheritance)
//--------------------------------------------------------------------
// 메모
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class Animal {
public:
	void move() {
		cout << "움직이니까 동물이다" << endl;
	}
private:
	int n;
};

class Dog : public Animal {
private:
	double d;
};

class Bird : public Animal {

};

//-----------
int main()
//-----------
{
	save("메인.cpp");

	Dog dog;

	dog.move();
}



======================================
저장시간:2024-11-28 16:55:47.4846374
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> 장소변경예정
// 
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속(inheritance)
//--------------------------------------------------------------------
// 메모
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class Animal {
public:
	void move() const {
		cout << "움직이니까 동물이다" << endl;
	}
private:
	int n;
};

class Dog : public Animal {
public:
	void move() const {
		cout << "개 후달린다" << endl;
	}
private:
	double d;
};

class Bird : public Animal {

};

//-----------
int main()
//-----------
{
	save("메인.cpp");

	Dog dog;

	dog.move();
}



======================================
저장시간:2024-11-28 17:12:49.1958196
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> 장소변경예정
// 
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속(inheritance)
//--------------------------------------------------------------------
// 메모
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class Animal {
public:
	void move() const {
		cout << "움직이니까 동물이다" << endl;
	}
private:
	int n;
};

class Dog : public Animal {
public:
	
private:
	double d;
};

class Bird : public Animal {

};

//-----------
int main()
//-----------
{
	save("메인.cpp");

	Dog dog;

	Dog* pDog = { &dog };

	pDog->move();
}



======================================
저장시간:2024-11-28 17:13:31.0463206
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> 장소변경예정
// 
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속(inheritance)
//--------------------------------------------------------------------
// 메모
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class Animal {
public:
	void move() const {
		cout << "움직이니까 동물이다" << endl;
	}
private:
	int n;
};

class Dog : public Animal {
public:
	
private:
	double d;
};

class Bird : public Animal {

};

//-----------
int main()
//-----------
{
	save("메인.cpp");

	Dog dog;

	Dog* pDog = { &dog };

	((Animal*)pDog)->move();	// 이런 과정이 자동으로 일어나서 돌아간다.
}
}



======================================
저장시간:2024-11-28 17:16:01.9048981
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> 장소변경예정
// 
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속(inheritance)
//--------------------------------------------------------------------
// 메모
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class Animal {
public:
	void move() const {
		cout << "움직이니까 동물이다" << endl;
	}
private:
	int n;
};

class Dog : public Animal {
public:
	
private:
	double d;
};

class Bird : public Animal {

};

//-----------
int main()
//-----------
{
	save("메인.cpp");

	// 오늘은 여기까지 나머진 동영상 

	Dog dog;

	Dog* pDog = { &dog };

	Animal* pAnimal = pDog;
}


//--------------------------------------------------------------------
// 온라인 강의 
//--------------------------------------------------------------------




======================================
저장시간:2024-12-04 15:39:03.5149728
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속(inheritance)
//--------------------------------------------------------------------
// 메모
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class Animal {
private:
	int a;
};

class Dog : public Animal {
private:
	double d;
};

class Bird : public Animal {
private:
	int b;
};

//-----------
int main()
//-----------
{
	save("메인.cpp");

	// apahfl zmrl ghkrdls
	cout << "Animaldml zmrl - " << sizeof Animal << endl;
	cout << "Dogdml zmrl - " << sizeof Dog << endl;
	cout << "Birddml zmrl - " << sizeof Bird << endl;
}



======================================
저장시간:2024-12-04 15:39:51.0464722
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속(inheritance)
//--------------------------------------------------------------------
// 메모
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class Animal {
private:
	int a;
};

class Dog : public Animal {
private:
	double d;
};

class Bird : public Animal {
private:
	int b;
};

//-----------
int main()
//-----------
{
	save("메인.cpp");

	// 메모리 크기 확인
	cout << "Animal의 크기 - " << sizeof Animal << endl;
	cout << "Dog의 크기 - " << sizeof Dog << endl;
	cout << "Bird의 크기 - " << sizeof Bird << endl;
}



======================================
저장시간:2024-12-04 15:44:33.8856556
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속(inheritance)
//--------------------------------------------------------------------
// 메모
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class Animal {
public:
	void move() const {
		cout << "동물의 move" << endl;
	}

private:
	int a;
};

class Dog : public Animal {
public:
	void move() const {
		cout << "Dog 달린다" << endl;
	}
private:
	double d;
};

class Bird : public Animal {
public:
	void move() const {
		cout << "Bird 난다" << endl;
	}
private:
	int b;
};

//-----------
int main()
//-----------
{
	save("메인.cpp");

	Animal animal;
	Dog dog;
	Bird bird;

	animal.move();
	dog.move();
	bird.move();
}



======================================
저장시간:2024-12-04 16:01:11.6827962
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속(inheritance)
//--------------------------------------------------------------------
// 메모
// C++ 에서는 컴파일러가 name mangling을 하기에 function overloading이 가능하다
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class Animal {
public:
	virtual void move() const {
		cout << "동물의 move" << endl;
	}

private:
	int a;
};

class Dog : public Animal {
public:
	void move() const {
		cout << "Dog 달린다" << endl;
	}
private:
	double d;
};

class Bird : public Animal {
public:
	void move() const {
		cout << "Bird 난다" << endl;
	}
private:
	int b;
};

//-----------
int main()
//-----------
{
	save("메인.cpp");

	Animal animal;
	Dog dog;
	Bird bird;

	cout << "Animal의 크기 - " << sizeof animal << endl;
	cout << "Dog의 크기 - " << sizeof Dog << endl;
	cout << "Bird의 크기 - " << sizeof Bird << endl;
}



======================================
저장시간:2024-12-04 16:07:41.5108541
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속(inheritance)
//--------------------------------------------------------------------
// 메모
// C++ 에서는 컴파일러가 name mangling을 하기에 function overloading이 가능하다
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class Animal {
public:
	virtual void move() const {
		cout << "동물의 move" << endl;
	}

private:
	int a;
};

class Dog : public Animal {
public:
	void move() const {
		cout << "Dog 달린다" << endl;
	}
private:
	double d;
};

class Bird : public Animal {
public:
	void move() const {
		cout << "Bird 난다" << endl;
	}
private:
	int b;
};

//-----------
int main()
//-----------
{
	save("메인.cpp");

	Animal animal;
	Dog dog;
	Bird bird;

	cout << "Animal의 크기 - " << sizeof animal << endl;
	cout << "Dog의 크기 - " << sizeof Dog << endl;
	cout << "Bird의 크기 - " << sizeof Bird << endl;
	// 시험 1번으로 나올 확률 높음( 추가 내용 붙여서 )
	// virtual 때문에 animal 객체를 하나 만들때마다 포인터 하나를 소비한다(v.ptr)
	// dog도 마찬가지로 animal과 동일하게 메모리를 확보한다->16byte 에다가 double d로 8byte 추가
	// bird도 조상클래스의 메모리가 동일하게 오고 int b가 뒤에 붙혀져 총 24byte
	// 조상의 빈 메모리 공간에 후대가 침투할 수 없다.
}



======================================
저장시간:2024-12-04 16:08:16.9480664
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속(inheritance)
//--------------------------------------------------------------------
// 메모
// C++ 에서는 컴파일러가 name mangling을 하기에 function overloading이 가능하다
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class Animal {
public:
	virtual void move() const {
		cout << "동물의 move" << endl;
	}

private:
	int a;
};

class Dog : public Animal {
public:
	void move() const {
		cout << "Dog 달린다" << endl;
	}
private:
	double d;
};

class Bird : public Animal {
public:
	void move() const {
		cout << "Bird 난다" << endl;
	}
private:
	int b;
};

//-----------
int main()
//-----------
{
	save("메인.cpp");

	Animal animal;
	Dog dog;
	Bird bird;

	animal.move();
	dog.move();
	bird.move();
}



======================================
저장시간:2024-12-04 16:20:52.9928567
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속(inheritance)
//--------------------------------------------------------------------
// 메모
// C++ 에서는 컴파일러가 name mangling을 하기에 function overloading이 가능하다
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class Animal {
public:
	virtual void move() const {
		cout << "동물의 move" << endl;
	}

private:
	int a;
};

class Dog : public Animal {
public:
	void move() const {
		cout << "Dog 달린다" << endl;
	}
private:
	double d;
};

class Bird : public Animal {
public:
	void move() const {
		cout << "Bird 난다" << endl;
	}
private:
	int b;
};

//-----------
int main()
//-----------
{
	save("메인.cpp");

	Animal animal;
	Dog dog;
	Bird bird;

	// 다형성( polymorphism )을 구현하려면 객체를 부모의 *로 가리켜야 한다.

	Animal* animals[3];
	animals[0] = &animal;
	animals[1] = &bird;
	animals[2] = &dog;

	// 모든 동물들에게 move()를 호출한다.
	for (int i = 0; i < 3; ++i)
		animals[i]->move();		// 이 함수는 dynamic binding
}



======================================
저장시간:2024-12-04 16:21:10.7115817
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속(inheritance)
//--------------------------------------------------------------------
// 메모
// C++ 에서는 컴파일러가 name mangling을 하기에 function overloading이 가능하다
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class Animal {
public:
	void move() const {		// virtual을 넣지 않으면 다형성 구현이 되지 않음
		cout << "동물의 move" << endl;
	}

private:
	int a;
};

class Dog : public Animal {
public:
	void move() const {
		cout << "Dog 달린다" << endl;
	}
private:
	double d;
};

class Bird : public Animal {
public:
	void move() const {
		cout << "Bird 난다" << endl;
	}
private:
	int b;
};

//-----------
int main()
//-----------
{
	save("메인.cpp");

	Animal animal;
	Dog dog;
	Bird bird;

	// 다형성( polymorphism )을 구현하려면 객체를 부모의 *로 가리켜야 한다.

	Animal* animals[3];
	animals[0] = &animal;
	animals[1] = &bird;
	animals[2] = &dog;

	// 모든 동물들에게 move()를 호출한다.
	for (int i = 0; i < 3; ++i)
		animals[i]->move();		// 이 함수는 dynamic binding
	// 다형성에서 메모리를 더 써서 얻는 이득은 유연함이다. 
}



======================================
저장시간:2024-12-04 16:35:59.3302432
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속(inheritance)
//--------------------------------------------------------------------
// 메모
// C++ 에서는 컴파일러가 name mangling을 하기에 function overloading이 가능하다
//--------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

class Animal {
public:
	virtual void move() const {
		cout << "동물의 move" << endl;
	}

private:
	int a;
};

class Dog : public Animal {
public:
	void move() const {
		cout << "Dog 달린다" << endl;
	}
private:
	double d;
};

class Bird : public Animal {
public:
	void move() const {
		cout << "Bird 난다" << endl;
	}
private:
	int b;
};

default_random_engine dre;
uniform_int_distribution uid{ 0,1 };

//-----------
int main()
//-----------
{
	save("메인.cpp");

	// [문제] 동물 호텔을 운영하고 있다.
	// 몇 마리가 숙박하기를 원하는 지 입력받자.(Dog와 Bird를 합한 수)
	// 홀수면 Dog, 짝수면 Bird를 배정한다.

	cout << "몇 마리인가요? ";
	size_t num;
	cin >> num;

	Animal** animals = new Animal* [num];

	for (int i = 0; i < num; ++i) {
		int sel = uid(dre);
		if ( 1 == sel )
			animals[i] = new Dog;
		else
			animals[i] = new Bird;
	}
}



======================================
저장시간:2024-12-04 16:36:58.8372473
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속(inheritance)
//--------------------------------------------------------------------
// 메모
// C++ 에서는 컴파일러가 name mangling을 하기에 function overloading이 가능하다
//--------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

class Animal {
public:
	virtual void move() const {
		cout << "동물의 move" << endl;
	}

private:
	int a;
};

class Dog : public Animal {
public:
	void move() const {
		cout << "Dog 달린다" << endl;
	}
private:
	double d;
};

class Bird : public Animal {
public:
	void move() const {
		cout << "Bird 난다" << endl;
	}
private:
	int b;
};

default_random_engine dre;
uniform_int_distribution uid{ 0,1 };

//-----------
int main()
//-----------
{
	save("메인.cpp");

	// [문제] 동물 호텔을 운영하고 있다.
	// 몇 마리가 숙박하기를 원하는 지 입력받자.(Dog와 Bird를 합한 수)
	// 홀수면 Dog, 짝수면 Bird를 배정한다.

	cout << "몇 마리인가요? ";
	size_t num;
	cin >> num;

	Animal** animals = new Animal* [num];

	for (int i = 0; i < num; ++i) {
		int sel = uid(dre);
		if ( 1 == sel )
			animals[i] = new Dog;
		else
			animals[i] = new Bird;
	}

	// 전체 동물들에게 move 명령을 내린다.
	for (int i = 0; i < num; ++i)
		animals[i]->move();
}



======================================
저장시간:2024-12-04 16:37:48.2583749
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속(inheritance)
//--------------------------------------------------------------------
// 메모
// C++ 에서는 컴파일러가 name mangling을 하기에 function overloading이 가능하다
//--------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

class Animal {
public:
	virtual void move() const {
		cout << "동물의 move" << endl;
	}

private:
	int a;
};

class Dog : public Animal {
public:
	void move() const {
		cout << "Dog 달린다" << endl;
	}
private:
	double d;
};

class Bird : public Animal {
public:
	void move() const {
		cout << "Bird 난다" << endl;
	}
private:
	int b;
};

default_random_engine dre;
uniform_int_distribution uid{ 0,1 };

//-----------
int main()
//-----------
{
	save("메인.cpp");

	// [문제] 동물 호텔을 운영하고 있다.
	// 몇 마리가 숙박하기를 원하는 지 입력받자.(Dog와 Bird를 합한 수)
	// 홀수면 Dog, 짝수면 Bird를 배정한다.

	cout << "몇 마리인가요? ";
	size_t num;
	cin >> num;

	Animal** animals = new Animal* [num];

	for (int i = 0; i < num; ++i) {
		int sel = uid(dre);
		if ( 1 == sel )
			animals[i] = new Dog;
		else
			animals[i] = new Bird;
	}

	// 전체 동물들에게 move 명령을 내린다.
	for (int i = 0; i < num; ++i) {
		cout << i + 1 << " - ";
		animals[i]->move();
	}
}



======================================
저장시간:2024-12-04 16:45:47.2416295
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속(inheritance)
//--------------------------------------------------------------------
// 메모
// C++ 에서는 컴파일러가 name mangling을 하기에 function overloading이 가능하다
//--------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

class Animal {
public:
	virtual void move() const {
		cout << "동물의 move" << endl;
	}

private:
	int a;
};

class Dog : public Animal {
public:
	void move() const {
		cout << "Dog 달린다" << endl;
	}
private:
	double d;
};

class Bird : public Animal {
public:
	void move() const {
		cout << "Bird 난다" << endl;
	}
private:
	int b;
};

default_random_engine dre;
uniform_int_distribution uid{ 0,1 };

//-----------
int main()
//-----------
{
	save("메인.cpp");

	// [문제] 동물 호텔을 운영하고 있다.
	// 몇 마리가 숙박하기를 원하는 지 입력받자.(Dog와 Bird를 합한 수)
	// 홀수면 Dog, 짝수면 Bird를 배정한다.
	while (true) {
		cout << "몇 마리인가요? ";
		size_t num;
		cin >> num;

		Animal** animals = new Animal * [num];

		for (int i = 0; i < num; ++i) {
			int sel = uid(dre);
			if (1 == sel)
				animals[i] = new Dog;
			else
				animals[i] = new Bird;
		}

		// 전체 동물들에게 move 명령을 내린다.
		for (int i = 0; i < num; ++i) {
			cout << i + 1 << " - ";
			animals[i]->move();
		}

		// free store에 확보한 메모리를 반환한다.
		for (int i = 0; i < num; ++i)
			delete animals[i];

		delete[] animals;
	}
}



======================================
저장시간:2024-12-04 16:48:09.5309624
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속(inheritance)
//--------------------------------------------------------------------
// 메모
// C++ 에서는 컴파일러가 name mangling을 하기에 function overloading이 가능하다
//--------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

class Animal {
public:
	// Animal은 모든 동물의 공통 속성을 표현하기 위한 추상(Abstract)클래스이다.
	// 추상클래스는 instancing 하지 않는 것이 자연스럽다.
	// 이때 조상의 move 함수를 순수가상함수(pure virtual function)로 만든다.
	virtual void move() const {
		cout << "동물의 move" << endl;
	}

private:
	int a;
};

class Dog : public Animal {
public:
	void move() const {
		cout << "Dog 달린다" << endl;
	}
private:
	double d;
};

class Bird : public Animal {
public:
	void move() const {
		cout << "Bird 난다" << endl;
	}
private:
	int b;
};

default_random_engine dre;
uniform_int_distribution uid{ 0,1 };

//-----------
int main()
//-----------
{
	save("메인.cpp");

	// [문제] 동물 호텔을 운영하고 있다.
	// 몇 마리가 숙박하기를 원하는 지 입력받자.(Dog와 Bird를 합한 수)
	// 홀수면 Dog, 짝수면 Bird를 배정한다.
	while (true) {
		cout << "몇 마리인가요? ";
		size_t num;
		cin >> num;

		Animal** animals = new Animal * [num];

		for (int i = 0; i < num; ++i) {
			int sel = uid(dre);
			if (1 == sel)
				animals[i] = new Dog;
			else
				animals[i] = new Bird;
		}

		// 전체 동물들에게 move 명령을 내린다.
		for (int i = 0; i < num; ++i) {
			cout << i + 1 << " - ";
			animals[i]->move();
		}

		// free store에 확보한 메모리를 반환한다.
		for (int i = 0; i < num; ++i)
			delete animals[i];

		delete[] animals;
	}
}



======================================
저장시간:2024-12-04 16:50:25.0278219
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 11. 27 한 시간 강의 못한 내용 - 동영상으로 일요일까지 업로드
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// 클래스 간의 관계 - 상속(inheritance)
//--------------------------------------------------------------------
// 메모
// C++ 에서는 컴파일러가 name mangling을 하기에 function overloading이 가능하다
//--------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

class Animal {
public:
	// Animal은 모든 동물의 공통 속성을 표현하기 위한 추상(Abstract)클래스이다.
	// 추상클래스는 instancing 하지 않는 것이 자연스럽다.
	// 이때 조상의 move 함수를 순수가상함수(pure virtual function)로 만든다.
	virtual void move() const {
		cout << "동물의 move" << endl;
	}

private:
	int a;
};

class Dog : public Animal {
public:
	virtual void move() const override final {
		cout << "Dog 달린다" << endl;
	}
private:
	double d;
};

class Bird : public Animal {
public:
	void move() const {
		cout << "Bird 난다" << endl;
	}
private:
	int b;
};

default_random_engine dre;
uniform_int_distribution uid{ 0,1 };

//-----------
int main()
//-----------
{
	save("메인.cpp");

	// [문제] 동물 호텔을 운영하고 있다.
	// 몇 마리가 숙박하기를 원하는 지 입력받자.(Dog와 Bird를 합한 수)
	// 홀수면 Dog, 짝수면 Bird를 배정한다.
	while (true) {
		cout << "몇 마리인가요? ";
		size_t num;
		cin >> num;

		Animal** animals = new Animal * [num];

		for (int i = 0; i < num; ++i) {
			int sel = uid(dre);
			if (1 == sel)
				animals[i] = new Dog;
			else
				animals[i] = new Bird;
		}

		// 전체 동물들에게 move 명령을 내린다.
		for (int i = 0; i < num; ++i) {
			cout << i + 1 << " - ";
			animals[i]->move();
		}

		// free store에 확보한 메모리를 반환한다.
		for (int i = 0; i < num; ++i)
			delete animals[i];

		delete[] animals;
	}
}

7, 8 번 시험문제 1번부터 8번까지는 다 풀어보길바람.

======================================
저장시간:2024-12-11 15:39:16.0337541
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// template - generic programing의 핵심 키워드
// 함수 탬플릿 / 클래스 탬플릿 2개를 만들어 보면서 필요성 이해
//--------------------------------------------------------------------
// 메모
// 
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

void change(int& x, int& y) {
	int c{x};
	x = y;
	y = c;
}

//-----------
int main()
//-----------
{
	save("메인.cpp");

	// [문제] 의도대로 실행되게 하자  
	// 화면 출력이 2, 1
	// change를 선언하고 정의하라.
	int a = { 1 }, b = { 2 };
	change(a, b);
	cout << a << ", " << b << endl;
}



======================================
저장시간:2024-12-11 15:53:07.0936745
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// template - generic programing의 핵심 키워드
// 함수 탬플릿 / 클래스 탬플릿 2개를 만들어 보면서 필요성 이해
//--------------------------------------------------------------------
// 메모
// 
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog(int n) :n{ n } { }
private:
	int n;

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.n;
	}
};

void change(int&, int&);
void change(Dog&, Dog&);

//-----------
int main()
//-----------
{
	save("메인.cpp");

	// [문제] 의도대로 실행되게 하자  
	// 화면 출력이 2, 1
	// change를 선언하고 정의하라.
	int a = { 1 }, b = { 2 };
	change(a, b);
	cout << a << ", " << b << endl;

	Dog dog1 = { 1 }, dog2 = { 2 };
	change(dog1, dog2);
	cout << dog1 << ", " << dog2 << endl;
}

void change(int& x, int& y) {
	int c{ x };
	x = y;
	y = c;
}

void change(Dog& x, Dog& y) {
	Dog c{ x };
	x = y;
	y = c;
}


======================================
저장시간:2024-12-11 15:55:01.6124192
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// template - generic programing의 핵심 키워드
// 함수 탬플릿 / 클래스 탬플릿 2개를 만들어 보면서 필요성 이해
//--------------------------------------------------------------------
// 메모
// 
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog(int n) :n{ n } { }

	operator int() {	// 타입 변환 연산자
		return n;
	}
	
private:
	int n;

	/*friend ostream& operator<<(ostream& os, const dog& dog) {
		return os << dog.n;
	}*/
};

void change(int&, int&);
void change(Dog&, Dog&);

//-----------
int main()
//-----------
{
	save("메인.cpp");

	// [문제] 의도대로 실행되게 하자  
	// 화면 출력이 2, 1
	// change를 선언하고 정의하라.
	int a = { 1 }, b = { 2 };
	change(a, b);
	cout << a << ", " << b << endl;

	Dog dog1 = { 1 }, dog2 = { 2 };
	change(dog1, dog2);
	cout << dog1 << ", " << dog2 << endl;
}

void change(int& x, int& y) {
	int c{ x };
	x = y;
	y = c;
}

void change(Dog& x, Dog& y) {
	Dog c{ x };
	x = y;
	y = c;
}


======================================
저장시간:2024-12-11 16:17:00.3169826
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// template - generic programing의 핵심 키워드
// 함수 탬플릿 / 클래스 탬플릿 2개를 만들어 보면서 필요성 이해
//--------------------------------------------------------------------
// 메모
// 
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog(int n) :n{ n } { }

	operator int() {	// 타입 변환 연산자
		return n;
	}
	
private:
	int n;

	/*friend ostream& operator<<(ostream& os, const dog& dog) {
		return os << dog.n;
	}*/
};

template <class X>
void change(X&, X&);

//-----------
int main()
//-----------
{
	save("메인.cpp");

	// [문제] 의도대로 실행되게 하자  
	// 화면 출력이 2, 1
	// change를 선언하고 정의하라.
	int a = { 1 }, b = { 2 };
	change(a, b);
	cout << a << ", " << b << endl;

	Dog dog1 = { 1 }, dog2 = { 2 };
	change(dog1, dog2);
	cout << dog1 << ", " << dog2 << endl;
}

template<class X>
void change(X& x, X& y) 
{
	X c{ x };
	x = y;
	y = c;
}




======================================
저장시간:2024-12-11 16:47:22.3313412
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// template - generic programing의 핵심 키워드
// 함수 탬플릿 / 클래스 탬플릿 2개를 만들어 보면서 필요성 이해
//--------------------------------------------------------------------
// 메모
// 
//--------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

class SafeIntArray {

public:
    // 생성자: 배열을 0으로 초기화
    SafeIntArray(int n) : num{ n } {
        p = new int[num];
    }

    int operator[](int idx) const {
        if (idx < 0 or num <= idx)
            throw 20241211;
        return p[idx];
    }

    int size() const {
        return num;
    }
private:
    int num;
    int* p;
};

//-----------
int main()
//-----------
{
    save("메인.cpp");

    // [문제] 의도대로 실행되게 하자  

    SafeIntArray a{ 10 };	// int 10개를 저장할 배열을 생성한다.

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;

    try {
        cout << a[10] << endl;      // 예외를 던져라.
    }
    catch (...) {
        cout << "경계를 벗어남 - 0 부터 " << 9 << "까지" << endl;
    }
}




======================================
저장시간:2024-12-11 16:50:38.3545823
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// template - generic programing의 핵심 키워드
// 함수 탬플릿 / 클래스 탬플릿 2개를 만들어 보면서 필요성 이해
//--------------------------------------------------------------------
// 메모
// 
//--------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

class SafeIntArray {

public:
    // 생성자: 배열을 0으로 초기화
    SafeIntArray(int n) : num{ n } {
        p = new int[num];
    }

    ~SafeIntArray() {
        delete[] p;
    }

    // 복사생성자/복사할당연산자를 코딩해야함
    // 이동/이동할당
    int operator[](int idx) const {
        if (idx < 0 or num <= idx)
            throw 20241211;
        return p[idx];
    }

    int size() const {
        return num;
    }
private:
    int num;
    int* p;
};

//-----------
int main()
//-----------
{
    save("메인.cpp");

    // [문제] 의도대로 실행되게 하자  

    SafeIntArray a{ 10 };	// int 10개를 저장할 배열을 생성한다.

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;

    try {
        cout << a[10] << endl;      // 예외를 던져라.
    }
    catch (...) {
        cout << "경계를 벗어남 - 0 부터 " << 9 << "까지" << endl;
    }
}




======================================
저장시간:2024-12-11 16:54:43.9712196
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// template - generic programing의 핵심 키워드
// 함수 탬플릿 / 클래스 탬플릿 2개를 만들어 보면서 필요성 이해
//--------------------------------------------------------------------
// 메모
// 
//--------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

template <class X> 
class SafeArray {
public:
    // 생성자: 배열을 0으로 초기화
    SafeArray(int n) : num{ n } {
        p = new X[num];
    }

    ~SafeArray() {
        delete[] p;
    }

    // 복사생성자/복사할당연산자를 코딩해야함
    // 이동/이동할당
    int operator[](int idx) const {
        if (idx < 0 or num <= idx)
            throw 20241211;
        return p[idx];
    }

    int size() const {
        return num;
    }
private:
    int num;
    X* p;
};

//-----------
int main()
//-----------
{
    save("메인.cpp");

    // [문제] 의도대로 실행되게 하자  

    SafeArray<int> a{ 10 };	// int 10개를 저장할 배열을 생성한다.

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;

    try {
        cout << a[10] << endl;      // 예외를 던져라.
    }
    catch (...) {
        cout << "경계를 벗어남 - 0 부터 " << 9 << "까지" << endl;
    }
}




======================================
저장시간:2024-12-11 17:00:33.9282906
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// template - generic programing의 핵심 키워드
// 함수 탬플릿 / 클래스 탬플릿 2개를 만들어 보면서 필요성 이해
//--------------------------------------------------------------------
// 메모
// 
//--------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

template <class X, int N> 
class SafeArray {
public:

    int operator[](int idx) const {
        if (idx < 0 or N <= idx)
            throw 20241211;
        return data[idx];
    }

    int size() const {
        return N;
    }
private:
    X data[N];
};

//-----------
int main()
//-----------
{
    save("메인.cpp");

    // [문제] 의도대로 실행되게 하자  

    SafeArray<int, 10> a;	// int 10개를 저장할 배열을 생성한다.

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;

    try {
        cout << a[10] << endl;      // 예외를 던져라.
    }
    catch (...) {
        cout << "경계를 벗어남 - 0 부터 " << 9 << "까지" << endl;
    }
}




======================================
저장시간:2024-12-11 17:03:05.6459139
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// template - generic programing의 핵심 키워드
// 함수 탬플릿 / 클래스 탬플릿 2개를 만들어 보면서 필요성 이해
//--------------------------------------------------------------------
// 메모
// 
//--------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
using namespace std;

//-----------
int main()
//-----------
{
    save("메인.cpp");

    array<int, 10> a;

    cout << "옛날 배열과 비교하여 메모리를 더 쓰지 않는다 - " << sizeof(a) << endl;
}




======================================
저장시간:2024-12-11 17:04:03.9378907
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// template - generic programing의 핵심 키워드
// 함수 탬플릿 / 클래스 탬플릿 2개를 만들어 보면서 필요성 이해
//--------------------------------------------------------------------
// 메모
// 
//--------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
using namespace std;

//-----------
int main()
//-----------
{
    save("메인.cpp");

    array<int, 12345> a;

    a.fill(333);

    for (int n : a)
        cout << n << " ";
    cout << endl;

    cout << "옛날 배열과 비교하여 메모리를 더 쓰지 않는다 - " << sizeof(a) << endl;
}




======================================
저장시간:2024-12-11 17:11:10.4630880
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// template - generic programing의 핵심 키워드
// 함수 탬플릿 / 클래스 탬플릿 2개를 만들어 보면서 필요성 이해
// -> T [N] 사용할 이유가 없다 ---> array<T,N>을 사용하자.
//--------------------------------------------------------------------
// 메모
// 
//--------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
using namespace std;

class SmartIntPtr {
public:
    SmartIntPtr(int* p) : p{ p } {      
        cout << "생성시 자원을 획득" << endl;
    }     // RAII
    ~SmartIntPtr() {
        cout << "획득한 자원 소멸" << endl;
        delete p;
    }
private:
    int* p;
};

//-----------
int main()
//-----------
{
    save("메인.cpp");

    SmartIntPtr p{ new int };   // RAII를 구현한 스마트 포인터
}




======================================
저장시간:2024-12-11 17:11:57.5390527
======================================

//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// template - generic programing의 핵심 키워드
// 함수 탬플릿 / 클래스 탬플릿 2개를 만들어 보면서 필요성 이해
// -> T [N] 사용할 이유가 없다 ---> array<T,N>을 사용하자.
//--------------------------------------------------------------------
// 메모
// 
//--------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
using namespace std;

class SmartIntPtr {
public:
    SmartIntPtr(int* p) : p{ p } {      
        cout << "생성시 자원을 획득" << endl;
    }     // RAII
    ~SmartIntPtr() {
        cout << "획득한 자원 소멸" << endl;
        delete p;
    }
private:
    int* p;
};

//-----------
int main()
//-----------
{
    save("메인.cpp");
    {
        SmartIntPtr p{ new int };   // RAII를 구현한 스마트 포인터
    }
    cout << "메인 끝" << endl;
}


//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// template - generic programing의 핵심 키워드
// 함수 탬플릿 / 클래스 탬플릿 2개를 만들어 보면서 필요성 이해
// -> T [N] 사용할 이유가 없다 ---> array<T,N>을 사용하자.
//--------------------------------------------------------------------
// 메모
// 
//--------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
using namespace std;

template <class T>
class SmartPtr {
public:
    SmartPtr( T* p) : p{ p } {      
        cout << "생성시 자원을 획득" << endl;
    }     // RAII
    ~SmartPtr() {
        cout << "획득한 자원 소멸" << endl;
        delete p;
    }
private:
    int* p;
};

class Dog {
    Dog() { cout << "Dog 생성" << endl; }
    ~Dog() { cout << "Dog 소멸" << endl; }
};

//-----------
int main()
//-----------
{
    save("메인.cpp");
    {
        SmartPtr<Dog> p{ new Dog };   // RAII를 구현한 스마트 포인터		
    }
    cout << "메인 끝" << endl;
}


//--------------------------------------------------------------------
//2024 2학기 11.20 수    수78 목78    (13주 1일)
//--------------------------------------------------------------------
// 일정
// 12/12 목요일 15주 1일차 - 종강
// 12/18 수요일 15주 2일차 - 기말시험 -> E동 219호
//
// 이 반 기말시험은 도형실습문제를 내기로 말해버림
//--------------------------------------------------------------------
// template - generic programing의 핵심 키워드
// 함수 탬플릿 / 클래스 탬플릿 2개를 만들어 보면서 필요성 이해
// -> T [N] 사용할 이유가 없다       ---> array<T,N>을 사용하자.
// -> T*    사용할 이유가 전혀 없다  ---> unique_ptr<T>, shared_ptr<T>
//--------------------------------------------------------------------
// 메모
// 
//--------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
using namespace std;

template <class T>
class SmartPtr {
public:
    SmartPtr( T* p) : p{ p } {      
        cout << "생성시 자원을 획득" << endl;
    }     // RAII
    ~SmartPtr() {
        cout << "획득한 자원 소멸" << endl;
        delete p;
    }
private:
    int* p;
};

class Dog {
    Dog() {
        cout << "Dog 생성" << endl; 
    }
    ~Dog() {
        cout << "Dog 소멸" << endl; 
    }
};

//-----------
int main()
//-----------
{
    save("메인.cpp");

    unique_ptr<Dog> p{ new Dog[1234] };

    cout << "raw pointer에 비해 메모리를 더 사용하지 않는다 - " << sizeof p << endl;
}





//--------------------------------------------------------------------------------------------------------------------------------------------
// 마지막 정리

!!Fundamental type

int n;   ---살 수 있는 곳--->  1. {int n;} 	-> STACK
X Y;					2. int n;	-> DATA
					3. new int;	-> free store
n의					   -> *로만 번지를 지정할 수 있다. -> delete로 짝을 맞춰서 지워줘야 한다. -> smart pointer
크기 파악																	 1. unique_ptr
1. sizeof n;																	 2. shared_ptr
2. addressof(n);
3. typeid(n).name();

!!user-defined Data Type
struct - default public; --->pair<>

class - default private;
{- encapsulation class { };
{- inheritance
{- polymorphism 

class X {			-> core guideline
public: 			-> cpprefrence
	X( );									-> 생성시 자원을 관리했다면 
	~X( );											(RAII)		
	X( const X& );			// 복사생성
	X& operator=(const X&);	// 복사할당

Modern C++ - Move semantic
 X(X&&);
 X& operator = (X&&);

operators
getter / setter												lhs	operators	rhs
T getname( ) const;   											   (+,[ ],<<,>>,++)
setter -> X													lhs -> 사용자가 만든 class -> member fn
													        	              X             -> global fn
friend fn
private:
    	member variables;
};

X a;	// instancing
   a->instance	
